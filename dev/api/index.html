<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>APIs · MetaFEM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MetaFEM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MetaFEM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/md/pikachu/pikachu/">Thermal conduction in a pikachu</a></li><li><a class="tocitem" href="../examples/md/pikachu_dynamics/pikachu_dynamics/">Thermal conduction in a pikachu, dynamic version</a></li><li><a class="tocitem" href="../examples/md/thermal_stripe/thermal_stripe/">Various thermal boundary conditions on a 2D stripe</a></li><li><a class="tocitem" href="../examples/md/cantilever/cantilever/">Linear elastic cantilever bending</a></li><li><a class="tocitem" href="../examples/md/stress_concentration/stress_concentration/">Stress concentration of a hole</a></li><li><a class="tocitem" href="../examples/md/thermal_elasticity/thermal_elasticity/">Thermal-hypoelasticity driven beam bending.</a></li><li><a class="tocitem" href="../examples/md/hyper_elasticity/hyper_elasticity/">Total-lagrangian hyper-elasticity</a></li><li><a class="tocitem" href="../examples/md/J2plasticity/J2plasticity/">J2 hypo-elastic-plasticity with mixed hardening</a></li><li><a class="tocitem" href="../examples/md/cylinderflow/cylinderflow/">Incompressible flow pass a cylinder</a></li><li><a class="tocitem" href="../examples/md/lid_driven_cavity/lid_driven_cavity/">Lid-driven cavity</a></li></ul></li><li class="is-active"><a class="tocitem" href>APIs</a><ul class="internal"><li><a class="tocitem" href="#Core"><span>Core</span></a></li><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#Symbolics"><span>Symbolics</span></a></li><li><a class="tocitem" href="#Assembly"><span>Assembly</span></a></li><li><a class="tocitem" href="#Update-simulation"><span>Update simulation</span></a></li><li><a class="tocitem" href="#Linear-solvers"><span>Linear solvers</span></a></li><li><a class="tocitem" href="#Other-helper-functions"><span>Other helper functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>APIs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Core"><a class="docs-heading-anchor" href="#Core">Core</a><a id="Core-1"></a><a class="docs-heading-anchor-permalink" href="#Core" title="Permalink"></a></h2><p>MetaFEM has three basic data structures:</p><ul><li>FEM_Domain, the overall system, defines <span>$Kx=d$</span>.</li><li>WorkPiece, a mesh assigned with physics, defines both domain physics and other numerical modifications like stabilization.</li><li>Boundary, an array of segment/face IDs assigned with physics, defines boundary condition.</li></ul><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.FEM_Domain" href="#MetaFEM.FEM_Domain"><code>MetaFEM.FEM_Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FEM_Domain</code></pre><p>A <code>FEM_Domain</code> contains everything needed to assemble a linear system <code>Kx=d</code> in FEM. The attributes are:</p><ul><li><code>dim</code>, the dimension, 2 or 3.</li><li><code>workpieces</code>, the array of all the <code>WorkPiece</code>s in this domain, which will be finally solved in fully coupling.</li><li><code>tools</code>, reserved for the external geometry <code>Tool</code>, e.g., for contact. Not implemented.</li><li><code>time_discretization</code>, the temporal discritization scheme. Currently only generalized-α method is implemented.</li><li><code>globalfield</code>, the container for sparse <code>K</code>, dense <code>x</code> and <code>d</code> in <code>Kx=d</code>.</li><li><code>K_linear_func</code> the generated function to update the linear part of <code>K</code>.</li><li><code>K_nonlinear_func</code> the generated function to update the nonlinear part of <code>K</code> and the residue <code>d</code>.</li><li><code>linear_solver</code>, the applied linear solver.</li></ul><p>To add a <code>FEM_Domain</code> of dimension <code>dim</code>, the exposed API is:</p><pre><code class="nohighlight hljs">FEM_Domain(; dim::Integer)</code></pre><p>which returns the new <code>FEM_Domain</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.WorkPiece" href="#MetaFEM.WorkPiece"><code>MetaFEM.WorkPiece</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WorkPiece</code></pre><p>A <code>WorkPiece</code> is a meshed part assigned with some known physics. The attributes are:</p><ul><li><code>ref_geometry</code>, the first order mesh to describe the FEM_Geometry.</li><li><code>physics</code>, the raw PDE weakforms.</li><li><code>local_assembly</code>, the re-organized PDE weakforms with sorted/indexed variables.</li><li><code>max_sd_order</code>, an explicit limit of the maximum spatial derivative order to save memory.</li><li><code>element_space</code>, the information about the spatial discritization, i.e., interpolation and intergration.</li><li><code>mesh</code>, the mesh regenerated according to the <code>element_space</code> and actually used in simulation.</li></ul><p>To add a <code>Workpiece</code> with the geometry <code>ref_geometry</code> to the <a href="#MetaFEM.FEM_Domain"><code>FEM_Domain</code></a> <code>fem_domain</code>, the exposed API is:</p><pre><code class="nohighlight hljs">add_WorkPiece!(ref_geometry; fem_domain::FEM_Domain)</code></pre><p>which returns the <code>WorkPiece</code> ID in the <code>fem_domain</code>.<code>workpieces</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.add_Boundary!" href="#MetaFEM.add_Boundary!"><code>MetaFEM.add_Boundary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_Boundary!(ID::Integer, bdy_ref_edge_IDs::CuVector; fem_domain::FEM_Domain = fem_domain, target::Symbol = :WorkPiece)</code></pre><p>In a 2D/3D <code>FEM_Domain</code> <code>fem_domain</code>, mark the segment/face IDs of the <code>WorkPiece</code> <code>fem_domain</code>.<code>workpieces</code>[<code>wp_ID</code>] as a boundary, to assign physics later. Multiple boundaries are independent from each other and can share the same segment/face IDs. If target = <code>:Tool</code>, the boundary is of <code>fem_domain</code>.<code>tools</code>[<code>wp_ID</code>], not implemented.</p><p>The function returns the boundary group ID <code>bg_ID</code>.</p></div></section></article><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><p>The input to define a mesh is (vert, connections), very similar to the mesh loading process in other fields, e.g., for plotting</p><ul><li>vert is a <span>$dim \times N_n$</span> CuArray of coordinates, where <span>$N_n$</span> is the number of nodes.</li><li>connections is a <span>$N_v \times N_e$</span> CuArray of sequenced node IDs where <span>$N_v$</span> is the number of nodes in each element and <span>$N_e$</span> is the total element number.</li></ul><p>To define (vert, connections), we have the following helper functions:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.make_Square" href="#MetaFEM.make_Square"><code>MetaFEM.make_Square</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_Square(x::Tuple, n::Tuple, shape = :CUBE)
make_Brick(x::Tuple, n::Tuple, shape = :CUBE)</code></pre><p>Helper functions to creates a grid, i.e., the mesh nodes are positioned at cubic lattice points, with mesh shape = <code>:CUBE</code> or <code>:SIMPLEX</code> defining the connections.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.read_Mesh" href="#MetaFEM.read_Mesh"><code>MetaFEM.read_Mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_Mesh(filename::String)</code></pre><p>The function loads an external mesh. Currently supported file types are:</p><ul><li><code>.inp</code> file, Abaqus first order mesh.</li><li><code>.mphtxt</code> file, COMSOL mesh.</li></ul></div></section></article><p>With (vert, connections), the first order mesh can be defined by:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.construct_TotalMesh" href="#MetaFEM.construct_TotalMesh"><code>MetaFEM.construct_TotalMesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_TotalMesh(coors, connections)
construct_TotalMesh(::Type{ArrayType}, coors, connections)</code></pre><p>The function reads (vert, connections) and declares the first order mesh, <code>FEM_Geometry</code>.  If not explicitly declared, the defualt ArrayType is <code>DEFAULT_ARRAYINFO</code>.<code>_type</code>, which is GPU_DeviceArray if unspecified.</p><p>There are 4 concepts in a <code>FEM_Geometry</code>:</p><ul><li>Each vertex in <code>vertices</code> stores the vertex coordinates.</li><li>Each segment in <code>segments</code> stores the vertex IDs connected to this segment.</li><li>Each face in <code>faces</code> stores both the vertex IDs and the segment IDs connected to this face.</li><li>Each block in <code>blocks</code> stores the vertex IDs, the segment IDs and the face IDs connected to this block.</li></ul><p>If applicable, the IDs are in order, e.g., segment IDs in a face are clockwise/counter-clockwise (since we can&#39;t define an outward normal for a bare face).</p><p>The function returns either a <code>Geo_TotalMesh2D</code> with attributes (<code>vertices</code>, <code>segments</code>, <code>faces</code>) or a  <code>Geo_TotalMesh3D</code> with attributes (<code>vertices</code>, <code>segments</code>, <code>faces</code>, <code>blocks</code>).</p></div></section></article><p>We also have the helper function to define boundaries:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.get_BoundaryMesh" href="#MetaFEM.get_BoundaryMesh"><code>MetaFEM.get_BoundaryMesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_BoundaryMesh(total_mesh::Geo_TotalMesh2D)
get_BoundaryMesh(total_mesh::Geo_TotalMesh3D)</code></pre><p>Helper function to collect all the segment/face IDs which can be marked as boundary.</p></div></section></article><h2 id="Symbolics"><a class="docs-heading-anchor" href="#Symbolics">Symbolics</a><a id="Symbolics-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics" title="Permalink"></a></h2><p>The APIs to define the physics are pretty straightforward:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.@Sym" href="#MetaFEM.@Sym"><code>MetaFEM.@Sym</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@Sym (name, attribute_1, attribute_2,...)
@External_Sym (name, attribute_1, attribute_2,...)</code></pre><p><code>@Sym</code> declares a variable symbol <code>name</code> with the attributes <code>attribute_1</code>, <code>attribute_2</code>, ...,  which is simply stored as the pair <code>name</code> =&gt; (<code>attribute_1</code>, <code>attribute_2</code>, ...) in the exposed global dictionary <code>VARIABLE_ATTRIBUTES</code>.</p><p><code>@External_Sym</code> is just the <code>@Sym</code> with one default attribute: <code>:EXTERNAL_VAR</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.@Def" href="#MetaFEM.@Def"><code>MetaFEM.@Def</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@Def ex 
@Def begin
    ex1
    ex2
    ...
end</code></pre><p><code>@Def</code> defines a symbolic term, e.g., 1, <code>σ{i, j}</code>`, Bilinear(⋅, ⋅), etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.assign_Boundary_WeakForm!" href="#MetaFEM.assign_Boundary_WeakForm!"><code>MetaFEM.assign_Boundary_WeakForm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assign_WorkPiece_WeakForm!(wp_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)
assign_Boundary_WeakForm!(wp_ID::Integer, bg_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)</code></pre><p>The functions assign <code>this_term</code>, which is either a bilinear term Bilinear(⋅, ⋅), or a sum of the bilinear terms, to the target <code>WorkPiece</code> or boundary.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.visualize" href="#MetaFEM.visualize"><code>MetaFEM.visualize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visualize(x::Union{SymbolicWord, SymbolicTerm, SubtermVariable, FunctionVariable, RewritingRule, Symbolic_BilinearForm, Symbolic_WeakForm})</code></pre><p>Print the expressions.</p></div></section></article><h2 id="Assembly"><a class="docs-heading-anchor" href="#Assembly">Assembly</a><a id="Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly" title="Permalink"></a></h2><p>There are some necessary preprocesses:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.initialize_LocalAssembly!" href="#MetaFEM.initialize_LocalAssembly!"><code>MetaFEM.initialize_LocalAssembly!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_LocalAssembly!(fem_domain::FEM_Domain; explicit_max_sd_order::Integer = 9)
initialize_LocalAssembly!(dim::Integer, workpieces::Vector{WorkPiece}; explicit_max_sd_order::Integer = 9)</code></pre><p>This function preprocesses/reorganizes the weakforms. The input <code>explicit_max_sd_order</code> is the exposed API for  explicitly limit high order spatial derivative.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.mesh_Classical" href="#MetaFEM.mesh_Classical"><code>MetaFEM.mesh_Classical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh_Classical(wp_IDs; shape::Symbol, itp_type::Symbol = :Lagrange, itp_order::Integer, itg_order::Integer, fem_domain::FEM_Domain)</code></pre><p>The function generates the mesh of order <code>itp_order</code>, interpolation type <code>itp_type</code> = <code>:Lagrange</code>/<code>:Serendipity</code> with gaussian quadrature of order <code>itg_order</code> on <code>fem_domain</code>.<code>workpieces</code>[<code>wp_IDs</code>]. The dimension and mesh type (<code>:CUBE</code>/<code>:SIMPLEX</code>) will follow the first order mesh of each <code>WorkPiece</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.compile_Updater_GPU" href="#MetaFEM.compile_Updater_GPU"><code>MetaFEM.compile_Updater_GPU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compile_Updater_GPU(; domain_ID::Integer, fem_domain::FEM_Domain)</code></pre><p>The function generates <code>fem_domain</code>.<code>K_linear_func</code> and <code>fem_domain</code>.<code>K_nonlinear_func</code>. The input <code>domain_ID</code> is only used to generate the function name.</p></div></section></article><h2 id="Update-simulation"><a class="docs-heading-anchor" href="#Update-simulation">Update simulation</a><a id="Update-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Update-simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.update_Mesh" href="#MetaFEM.update_Mesh"><code>MetaFEM.update_Mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_Mesh(dim::Integer, wp::WorkPiece, this_space::Classical_Discretization)</code></pre><p>This function updates Jacobians and interpolation values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.assemble_Global_Variables!" href="#MetaFEM.assemble_Global_Variables!"><code>MetaFEM.assemble_Global_Variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_Global_Variables!(; fem_domain::FEM_Domain)</code></pre><p>This function allocates the sparse <code>K</code>, dense <code>x</code> and <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.update_OneStep!" href="#MetaFEM.update_OneStep!"><code>MetaFEM.update_OneStep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_OneStep!(time_discretization::GeneralAlpha; max_iter::Integer = 4, fem_domain::FEM_Domain)</code></pre><p>This function calculates <code>K(Δx)=d</code> and updates <code>x += (Δx)</code>. <code>max_iter</code> determines the maximum iteration for Δx with different <code>K</code> and <code>d</code> in nonlinear cases. The converge tolerance is determined by <code>fem_domain</code>.<code>globalfield</code>.<code>converge_tol</code> while the linear solver is <code>fem_domain</code>.<code>linear_solver</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.assemble_X!" href="#MetaFEM.assemble_X!"><code>MetaFEM.assemble_X!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_X!(workpieces::Vector{WorkPiece}, globalfield::GlobalField)</code></pre><p>This function assembles/synchronizes local data to <code>globalfield</code>.<code>x</code>, i.e., to setup the initial values for some <code>workpiece</code>.<code>mesh</code>.<code>controlpoint</code>.<code>sym</code>, like <code>workpiece.mesh.controlpoint.T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.dessemble_X!" href="#MetaFEM.dessemble_X!"><code>MetaFEM.dessemble_X!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dessemble_X!(workpieces::Vector{WorkPiece}, globalfield::GlobalField)</code></pre><p>This function dessembles <code>globalfield</code>.<code>x</code> to local data, i.e., for ploting some <code>workpiece</code>.<code>mesh</code>.<code>controlpoint</code>.<code>sym</code>, like <code>workpiece.mesh.controlpoint.T</code>.</p></div></section></article><h2 id="Linear-solvers"><a class="docs-heading-anchor" href="#Linear-solvers">Linear solvers</a><a id="Linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers" title="Permalink"></a></h2><p>In update_OneStep, the linear solver, fem_domain.linear_solver is called, which is supposed to take a globalfield and return the dx. We provide the following linear solvers:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.solver_LU_CPU" href="#MetaFEM.solver_LU_CPU"><code>MetaFEM.solver_LU_CPU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver_LU_CPU(globalfield)</code></pre><p>CPU LU solver.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.solver_QR_GPU" href="#MetaFEM.solver_QR_GPU"><code>MetaFEM.solver_QR_GPU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver_QR_GPU(globalfield; reorder::Integer = 1, singular_tol::Number)</code></pre><p>GPU QR solver with <code>CUDA</code>&#39;s <code>csrlsvqr!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.solver_LU_GPU" href="#MetaFEM.solver_LU_GPU"><code>MetaFEM.solver_LU_GPU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver_LU_CPU(globalfield; reorder::Integer = 1, singular_tol::Number)</code></pre><p>GPU LU solver with <code>CUDA</code>&#39;s <code>csrlsvlu!</code>. Note, <code>csrlsvlu!</code> is essentially a host function and the device part is not accessible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.iterative_Solve!" href="#MetaFEM.iterative_Solve!"><code>MetaFEM.iterative_Solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterative_Solve!(globalfield::GlobalField; Sv_func!::Function = bicgstabl_GS!, Pr_func!::Function = Pr_Jacobi!, Pl_func::Function = Identity, max_pass = 4, kwargs...)</code></pre><p>Wrapper of general iterative solvers, where:</p><ul><li><code>Sv_func!</code> is the detailed iterative solver to be called with the folloiwng choices:<ul><li>BICG family: <code>bicgstabl_GS!</code>, <code>bicgstabl!</code>`</li><li>IDRS family: <code>idrs!</code>, <code>idrs_original!</code> </li><li>LSQR: <code>lsqr!</code></li><li>GMRES: <code>gmres!</code> </li></ul></li><li><code>Pr_func</code> is the right preconditioner function with the following choices:<ul><li><code>Identity</code>: do nothing.</li><li><code>Pr_Jacobi</code> (default): normalize each column by the diagnal element or the column norm. </li></ul></li><li><code>Pl_func</code> is the left preconditioner function with the following choices:<ul><li><code>Identity</code> (default): do nothing.</li><li><code>Pl_Jacobi</code>: normalize each row by the diagnal element or the row norm. </li><li><code>Pl_ILU</code>: ILU preconditioner provided by ilu02! in CUDA.jl.</li></ul></li><li><code>max_pass</code> is the number of attempts in one solving step, e.g., let max_pass = 4 and let maxiter = 3000 in idrs!, then the solver will run 4 (restarted) batches of 3000 iterations in solving every <code>Kx=d</code>.</li><li>Other <code>kwargs...</code> will be passed into <code>Sv_func!</code> as keyword arguments.</li></ul><p>Note, by default the iterative solver will be right Jacobi preconditioned only.  A right preconditioner modifies the matrix once when the solver begins and modifies the x once when the solver exits, i.e.,  roughly cost one more mat-vec mul!(mv!) and one more vec-vec axpy!. The right preconditioner will both ameliorate the numerical inaccuracy and reduce the iteration number from the ill-conditioning.</p><p>A left preconditioner modifies the vector every time a mat-vec mul! occurs, and it can only reduce the iteration number but not ameliorate the (condition number induced) numerical inaccuracy. However, left preconditioner can be more complicated, e.g., ILU, than the right preconditioner, for which only Jacobi can be practically applied when the matrix is large (in author&#39;s limited knowledge).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.bicgstabl!" href="#MetaFEM.bicgstabl!"><code>MetaFEM.bicgstabl!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bicgstabl!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 2, kwargs...)</code></pre><p>bicgstabl, a classical stablized bi conjugate gradient method, adapted from IterativeSolvers.jl.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.bicgstabl_GS!" href="#MetaFEM.bicgstabl_GS!"><code>MetaFEM.bicgstabl_GS!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bicgstabl_GS!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 2, kwargs...)</code></pre><p>bicgstabl, a classical stablized bi conjugate gradient method, where the &quot;GS&quot; suffix means using Gram-Schmidt instead of LU to solve the minimal residual part,  empirically more numerical stable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.idrs!" href="#MetaFEM.idrs!"><code>MetaFEM.idrs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">idrs!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 4, kwargs...)</code></pre><p>IDRs (induced dimension reduction) solver, adapted from IterativeSolvers.jl.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.idrs_original!" href="#MetaFEM.idrs_original!"><code>MetaFEM.idrs_original!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">idrs_original!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 4, kwargs...)</code></pre><p>IDRs (induced dimension reduction) solver, where the &quot;original&quot; suffix is the earlier version doing direct orthogonalization without exploit orthogonality incrementally.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.gmres!" href="#MetaFEM.gmres!"><code>MetaFEM.gmres!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gmres!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s = 20, kwargs...)</code></pre><p>Vanilla GMRES solver which restarts every s = 20 iteration. GMRES may enter early stagnation and leave with large residue/error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.lsqr!" href="#MetaFEM.lsqr!"><code>MetaFEM.lsqr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lsqr!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s = 20, kwargs...)</code></pre><p>LSQR solver, robust over most matrices, e.g., the ones generated randomly by <code>sprand</code>, where solvers like IDRs may explode. However, IDRs/... may converge much faster than LSQR when stable.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>cgs!</code>. Check Documenter&#39;s build log for details.</p></div></div><p>with the following preconditioners:</p><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.Identity" href="#MetaFEM.Identity"><code>MetaFEM.Identity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Identity(args...; kwargs...)</code></pre><p>Returns an identity preconditioner, i.e., do nothing at all.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.Pr_Jacobi!" href="#MetaFEM.Pr_Jacobi!"><code>MetaFEM.Pr_Jacobi!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pr_Jacobi!(A::CuSparseMatrixCSR{T}; normalized_by_column = false)</code></pre><p>GPU Jacobi right preconditioner. Each column of the matrix will be normalized, if <code>normalized_by_column</code> = <code>false</code> by the diagonal element, otherwise, by the column norm. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.Pl_Jacobi" href="#MetaFEM.Pl_Jacobi"><code>MetaFEM.Pl_Jacobi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pl_Jacobi(A::CuSparseMatrixCSR{T}; normalized_by_row = false)</code></pre><p>GPU Jacobi left preconditioner. Each row of the matrix will be normalized through modifying the final residue vector instead of the matrix, if <code>normalized_by_row</code> = <code>false</code>, by the diagonal element, otherwise, by the row norm. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.Pl_ILU" href="#MetaFEM.Pl_ILU"><code>MetaFEM.Pl_ILU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pl_ILU(A)</code></pre><p>GPU ILU preconditioner with <code>CUDA</code>&#39;s <code>ilu02!</code>.</p></div></section></article><p>where the prefix <code>Pl</code> denotes left preconditioners while the prefix <code>Pr</code>denotes right preconditioners. </p><h2 id="Other-helper-functions"><a class="docs-heading-anchor" href="#Other-helper-functions">Other helper functions</a><a id="Other-helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-helper-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.write_VTK" href="#MetaFEM.write_VTK"><code>MetaFEM.write_VTK</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_VTK(fname::String, wp::WorkPiece; scale = 1.)</code></pre><p>Output all the variables in <code>WorkPiece</code> <code>wp</code> to file <code>fname</code>. The <code>scale</code> is only for the length scale, i.e., node coordinates.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.@Takeout" href="#MetaFEM.@Takeout"><code>MetaFEM.@Takeout</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@Takeout a, b FROM c</code></pre><p>equals to</p><pre><code class="nohighlight hljs">a = c.a
b = c.b</code></pre><p>while</p><pre><code class="nohighlight hljs">@Takeout a, b FROM c WITH PREFIX d</code></pre><p>equals to</p><pre><code class="nohighlight hljs">da = c.a
db = c.b</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaFEM.MEM_UNIT" href="#MetaFEM.MEM_UNIT"><code>MetaFEM.MEM_UNIT</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">MEM_UNIT(unit_name::String)</code></pre><p>Set the displayed memory unit where <code>unit_name</code> can be &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/md/lid_driven_cavity/lid_driven_cavity/">« Lid-driven cavity</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 15 March 2022 22:39">Tuesday 15 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
