var documenterSearchIndex = {"docs":
[{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/pikachu_dynamics/pikachu_dynamics.jl\"","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/#Thermal-conduction-in-a-pikachu,-dynamic-version","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"","category":"section"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"(Image: global) (Image: slice)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"The previous example can be regarded as the final equilibrium state of a dynamic heating problem. To do a dynamic simulation, surely we can use MetaFEM as a pure spatial discretization package and write the customized timestep marching by ourselves, as in many other FEM packages. However, MetaFEM also provides an integrated generalized-alpha temporal discretization with only a little extra code, as in the following script. The source is also in the same folder as the last one.","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/#Geometry","page":"Thermal conduction in a pikachu, dynamic version","title":"Geometry","text":"","category":"section"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"The geometry in the same with the last case:","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"using MetaFEM\ninitialize_Definitions!()\nfem_domain = FEM_Domain(; dim = 3)\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary!(wp_ID, fIDs; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/#Physics","page":"Thermal conduction in a pikachu, dynamic version","title":"Physics","text":"","category":"section"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"In the mathematical formulation of a dynamic problem, a bilinear term with the time derivative is simply added:","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"-C(T T_t)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"while the full formulation is:","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"textvariablequad Tqquadtextparametersquad CkhT_envs","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"-C(T T_t)-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"h(TT_env-T)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"where the new C stands for the volumetric heat capacity.","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"Correspondingly, in the code there is simply another bilinear term with the time derivative, i.e., -C*Bilinear(T, T{;t}) in the domain physics, i.e., heat_dissipation:","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"C = 4.184 * 1e3 # C is simply chosen arbitrarily for convenience\nk = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\nα = 0.\n@Sym T\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - C * Bilinear(T, T{;t}) - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s + α * (Tₑₙᵥ - T))\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm!(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/#Assembly","page":"Thermal conduction in a pikachu, dynamic version","title":"Assembly","text":"","category":"section"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"No change.","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"initialize_LocalAssembly!(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables!(fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/#Run-and-Output","page":"Thermal conduction in a pikachu, dynamic version","title":"Run & Output","text":"","category":"section"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"Mostly the same as before, fem_domain.globalfield.dt is needed to be set. Note, the default generalized alpha (bi = 0.5, ci = 1) is unconditionally stable.","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = idrs!, maxiter = 2000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-6\nfem_domain.globalfield.dt = 1\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ\ncpts.s[cp_IDs] .= 1600.","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"Also we need to synchronize the initial temperature distribution by assemble_X!:","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"assemble_X!(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"Finally we simply only run 10 timestep and save each timestep in vtk because writing in VTK is relatively slow (.mp4 is 100 steps).","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"for i = 1:10\n    update_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\n    dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n    wp = fem_domain.workpieces[1]\n    write_VTK(joinpath(@__DIR__, \"history\", \"3D_MetaFEM_Result_$i.vtk\"), wp; scale = 100)\nend","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"","category":"page"},{"location":"examples/md/pikachu_dynamics/pikachu_dynamics/","page":"Thermal conduction in a pikachu, dynamic version","title":"Thermal conduction in a pikachu, dynamic version","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/hyper_elasticity/hyper_elasticity.jl\"","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Total-lagrangian-hyper-elasticity","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"(Image: NH) (Image: NH)","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"Extension to hyper-elasticity is very intuitive. We do a simple uniaxial loading case with the previous beam geometry. The source is here.","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Geometry","page":"Total-lagrangian hyper-elasticity","title":"Geometry","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"using MetaFEM\ninitialize_Definitions!()\nfem_domain = FEM_Domain(dim = 3)\nL_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio), e_number, e_number)\nelement_shape = :CUBE\n\nvert, connections = make_Brick(domain_size, element_number, element_shape)\n@time ref_mesh = construct_TotalMesh(vert, connections)\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary!(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary!(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top, facet_IDs_back); fem_domain = fem_domain) #bottom & right & front free\nright_bg_ID = add_Boundary!(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Physics","page":"Total-lagrangian hyper-elasticity","title":"Physics","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"The script should be very intuitive without any trick. Only note MetaFEM is able to do symbolic differentiation with respect to an intermediate tensor variable by the built-in function d.","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (Pˡ, CONTROLPOINT_VAR) (C10, GLOBAL_VAR) (C01, GLOBAL_VAR) (λ, GLOBAL_VAR) (τᵇ, GLOBAL_VAR)\n\n@Def begin\n    F{i,j} = δ{i,j} + d{i;j}\n    B{i,j} = F{i,k} * F{j,k}\n    I1 = B{i,i}\n    I2 = 0.5 * (B{i,i} ^ 2 - B{i,j} * B{j,i})\n    J = F{1,i} * F{2,j} * F{3,k} * ϵ{i,j,k}\n    W = C10 * (I1 - 3 - 2 * log(J)) + C01 * (I2 - 3 - 4 * log(J)) + 0.5 * λ * (J - 1) ^ 2 # Mooney-Rivlin\n    P{i,j} = d(W, F{i,j})\nend\n\n@Def begin\n    WF_domain = - Bilinear(F{i,j}, P{i,j})\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n    WF_right_bdy = Bilinear(d{i}, Pˡ{i,j} * n{j})\nend\n\n@time begin\n    assign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nend\ninitialize_LocalAssembly!(fem_domain)","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Assembly","page":"Total-lagrangian hyper-elasticity","title":"Assembly","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"Note the compilation may take a while (~6min on the developer's machine), which will be optimized in the future release.","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"@time mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\n@time begin\n    for wp in fem_domain.workpieces\n        update_Mesh(fem_domain.dim, wp, wp.element_space)\n    end\n    assemble_Global_Variables!(; fem_domain = fem_domain)\nend","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Run-and-Gather-Data","page":"Total-lagrangian hyper-elasticity","title":"Run & Gather Data","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = bicgstabl_GS!, maxiter = 3000, max_pass = 10, s = 4)\n\ndx = L_box/e_number\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nright_cp_IDs = findall((cpts.x1 .> (L_box * LW_ratio) - err_scale * dx) .& (cpts.x1 .< (L_box * LW_ratio) + err_scale * dx))\nleft_cp_IDs = findall((cpts.x1 .> - err_scale * dx) .& (cpts.x1 .< err_scale * dx))\n\nfem_domain.globalfield.converge_tol = 1e-5\n\nsetups = [(1e6, 1e6, 1e8, 30, 4e5), (1e6, 5e6, 1e8, 30, 5e5), (5e6, 1e6, 1e8, 40, 10e5)] #C10, C01, λ, total step, step load\nP1s_buffer, d1s_buffer = Vector[], Vector[]\nfor (_C10, _C01, _λ, total_steps, σ_step) in setups\n    P1s = FEM_Float[]\n    d1s = FEM_Float[]\n\n    fem_domain.workpieces[1].physics.global_vars[:C10] = _C10\n    fem_domain.workpieces[1].physics.global_vars[:C01] = _C01\n    fem_domain.workpieces[1].physics.global_vars[:λ] = _λ\n    fem_domain.workpieces[1].physics.global_vars[:τᵇ] = 1000 * max(_λ, _C10, _C01) / L_box\n\n    cpts.d1 .= 0\n    cpts.d2 .= 0\n    cpts.d3 .= 0\n    assemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n    for i = 1:total_steps\n        println(\"Global step $i\")\n\n        σ_load = σ_step * i\n        cpts.Pˡ1 .= σ_load\n\n        update_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain, max_iter = 7)\n        dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n        step_d1 = sum(cpts.d1[right_cp_IDs]) / (L_box * LW_ratio * length(right_cp_IDs))\n        push!(d1s, step_d1)\n        push!(P1s, σ_load)\n    end\n    push!(P1s_buffer, P1s)\n    push!(d1s_buffer, d1s)\nend","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/#Plots","page":"Total-lagrangian hyper-elasticity","title":"Plots","text":"","category":"section"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"Jac(l1, _C10, _C01, _λ) = l1 * (-(2 * _C10 + 2 * _C01 * l1 ^ 2 + _λ * l1) + sqrt((2 * _C10 + 2 * _C01 * l1 ^ 2 + _λ * l1) ^ 2 + 8 * _C01 * (_λ + 2 * _C10 + 4 * _C01))) / (4 * _C01)\nmooney_Rivlin(l1, _C10, _C01, _λ)  = 2 * _C10 * l1 + 4 * _C01 * Jac(l1, _C10, _C01, _λ) + (_λ * (Jac(l1, _C10, _C01, _λ) - 1) - 2 * _C10 - 4 * _C01) / l1\n\nusing Plots\nfig = plot(; size = (900,800), title = \"Uniaxial loading on Mooney-Rivlin hyper-elastic materials.\", xlims = (0., 2.2), xticks = 0:0.2:2, ylims = (0., 35), xlabel = \"Elongation\", ylabel = \"Nominal stress(MPa)\")\ncase_num = length(P1s_buffer)\nfor i = 1:case_num\n    color_val = (i / case_num + 1) / 2\n    P1s, d1s = P1s_buffer[i], d1s_buffer[i]\n    (_C10, _C01, _λ, _, _) = setups[i]\n    scatter!(fig, d1s, P1s ./ 1e6, markershape = :circle, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = \"numerical, C10 = $_C10 Pa, C01 = $_C01 Pa, λ = $_λ Pa\")\n    plot!(fig, d1s, mooney_Rivlin.(d1s .+ 1, _C10, _C01, _λ) ./ 1e6, color = RGBA(0, 0.5, color_val, 1), label = \"analytical, C10 = $_C10 Pa, C01 = $_C01 Pa, λ = $_λ Pa\")\nend\nfig.subplots[1].attr[:legend_position] = (0.15, 0.9)\nfig","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"","category":"page"},{"location":"examples/md/hyper_elasticity/hyper_elasticity/","page":"Total-lagrangian hyper-elasticity","title":"Total-lagrangian hyper-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/thermal_stripe/thermal_stripe.jl\"","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Various-thermal-boundary-conditions-on-a-2D-stripe","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"(Image: stripe1)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"This case is another thermal example, which is also a tutorial in FEATool. # The MetaFEM source with data/visualization can also be found here.","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Load the package and define the domain:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"using MetaFEM\ninitialize_Definitions!()\ndim = 2\nfem_domain = FEM_Domain(dim = dim)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Geometry","page":"Various thermal boundary conditions on a 2D stripe","title":"Geometry","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"For cuboid geometry we have helper functions \"make_Square\"/\"make_Brick\" for 2D/3D:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"L1, L2 = domain_size = (0.02, 0.01)\nΔx = 5e-4\nelement_number = Int.(domain_size ./ Δx) # 40 x 20 mesh\nelement_shape = :CUBE\n\nvert, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"To define the boundaries, we need to find those sIDs (segment IDs):","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = Δx * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L1 .+ err_scale)) .& (x1_mean .> (L1 .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L2 .+ err_scale)) .& (x2_mean .> (L2 .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary!(wp_ID, vcat(sIDs_left, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary!(wp_ID, sIDs_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Physics","page":"Various thermal boundary conditions on a 2D stripe","title":"Physics","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Similar to the pikachu case, but with volumetric heat dissipation, radiation boundary and fixed boundary, the mathematical formulation is:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"textvariablequad Tqquadtextparametersquad Ckhh_penaltyse_mT_envT_fix","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"-C(TT_t)-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"h(TT_env-T)+e_msigma^b(T T_env^4 - T^4)=0qquad onquadpartial(Omega)_convection_radiation","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"h_penalty(TT_fix-T) + k(Tn_iT_i)=0qquad onquadpartial(Omega)_fix","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Note, for the fixed boundary we use Nitsche's formulation, i.e., with the gradient correction term:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":" k(Tn_iT_i)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"we can reduce the magnitude of h_penalty to a much smaller value than the bare penalty case. The code is:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"T₀ = 273.15\nk = 3\nh = 50\nC = 1.\nα = 0.\nTw = 900. + T₀\nh_penalty = 1000.\nTₑₙᵥ = 50. + T₀\nem = 0.7\nσᵇ = 5.669e-8\n\n@Sym T\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s + α * (Tₑₙᵥ - T))\n    conv_rad_boundary = h * Bilinear(T, Tₑₙᵥ - T) + em * σᵇ * Bilinear(T, Tₑₙᵥ^4 - T^4)\n    fix_boundary = h_penalty * Bilinear(T, Tw - T) + k * Bilinear(T, n{i} * T{;i})\nend\n\nassign_WorkPiece_WeakForm!(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, fixed_bg_ID, fix_boundary; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, top_bg_ID, conv_rad_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Assembly","page":"Various thermal boundary conditions on a 2D stripe","title":"Assembly","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"initialize_LocalAssembly!(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Run","page":"Various thermal boundary conditions on a 2D stripe","title":"Run","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables!(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = idrs!, maxiter = 2000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-6\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ\ncpts.s[cp_IDs] .= 0.\n\nupdate_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Plot","page":"Various thermal boundary conditions on a 2D stripe","title":"Plot","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"With Plots.jl","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"using Plots\n\nmid_cp_IDs = (cpts.x1 .> L1/2 - 0.1 * Δx) .& (cpts.x1 .< L1/2 + 0.1 * Δx)\nnum_ys = cpts.x2[mid_cp_IDs] |> collect\nnum_Ts = cpts.T[mid_cp_IDs] |> collect\nids = sortperm(num_ys)\n\ny_sample = [0.0001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.0099] # Sampled from FEATool result\nT_sample = [1086.84,  1086,  1082.73,  1077.63,  1070.24,  1060.78,  1048.83,  1034.63,  1017.81,  998.843,  979.249]\n\nfig = plot(; size=(800,800), title = \"Temperature along the middle line x = 1 cm\", xticks = 0.:0.002:0.01, xlabel = \"y(m)\", ylabel = \"T(K)\" )\nscatter!(fig, y_sample, T_sample, markershape = :rect, markersize = 6, color = RGBA(1, 0, 0, 1), label = \"FEATool\")\nplot!(fig, num_ys[ids], num_Ts[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, 0.5, 1), markercolor = RGBA(0, 0.5, 0.5, 1), label = \"MetaFEM\")\nfig.subplots[1].attr[:legend_position] = (0.8, 0.9)\nfig","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"(Image: stripe2)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/thermal_elasticity/thermal_elasticity.jl\"","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/#Thermal-hypoelasticity-driven-beam-bending.","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"","category":"section"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"(Image: global)","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"Combining thermal conduction and linear elasticity, we can do a thermal induced beam bending. The source is here","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/#Geometry","page":"Thermal-hypoelasticity driven beam bending.","title":"Geometry","text":"","category":"section"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"The geometry in the same as the cantilever case.","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"using MetaFEM\ninitialize_Definitions!()\n\nfem_domain = FEM_Domain(dim = 3)\nL_box, e_number, LW_ratio = 1., 10, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvert, connections = make_Brick(domain_size, element_number, element_shape)\n@time ref_mesh = construct_TotalMesh(vert, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio .- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary!(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary!(wp_ID, vcat(facet_IDs_bottom, facet_IDs_top, facet_IDs_right); fem_domain = fem_domain) #bottom & right & front free\nthermal_bg_ID = add_Boundary!(wp_ID, vcat(facet_IDs_front, facet_IDs_back); fem_domain = fem_domain) #back will be loaded","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/#Physics","page":"Thermal-hypoelasticity driven beam bending.","title":"Physics","text":"","category":"section"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"The mathematical formulation is:","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"textvariablequad d_i T","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"epsilon_ij=fracd_ij+d_ji2-alpha*T*delta_ijqquadsigma_ij=lambdadelta_ijepsilon_mm+2muepsilon_ij","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"(d_ijsigma_ij)+(d_irho * c*fracpartial d_ipartial t)+C(Tfracpartial Tpartial t) + k(T_i T_i)=0qquad inquadOmega","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"(Th(T - Te)) = 0qquad onquad(partialOmega)_thermal","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"(d_itau*d_i)=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"The code is:","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"Δx = L_box / e_number\nE = 210e3\nν = 0.\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box\nρ = 1e3\nc =\nh = 100.\nC = 1000\nk = 100.\nα = 0.05e-3\n\n@Sym d T\n@External_Sym (Te, CONTROLPOINT_VAR)\n\n@Def begin\n    ε{i,j} = (d{i;j} + d{j;i}) / 2. - α * T * δ{i,j}\n    σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n\n    heat_dissipation = C * Bilinear(T, T{;t}) + k * Bilinear(T{;i}, T{;i})\n    elasticity = Bilinear(ε{i,j}, σ{i,j}) + Bilinear(d{i}, ρ * (c * d{i;t}))\n\n    domain = heat_dissipation + elasticity\n    conv_bdy = h * Bilinear(T, T - Te)  # free wall with environment temperature\n    fixed_bdy = τᵇ * Bilinear(d{i}, d{i}) # (d, d - 0) where 0 is the wall displacement, denoting fixed, adiabatic wall\nend\n\n@time begin\n    assign_WorkPiece_WeakForm!(wp_ID, domain; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, fix_bg_ID, fixed_bdy; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, thermal_bg_ID, conv_bdy; fem_domain = fem_domain)\nend\ninitialize_LocalAssembly!(fem_domain)","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/#Assembly","page":"Thermal-hypoelasticity driven beam bending.","title":"Assembly","text":"","category":"section"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"@time mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)[2]\n\n@time begin\n    wp = fem_domain.workpieces[1]\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\n    assemble_Global_Variables!(; fem_domain = fem_domain)\nend","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/#Run-and-Gather-Data","page":"Thermal-hypoelasticity driven beam bending.","title":"Run & Gather Data","text":"","category":"section"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = bicgstabl_GS!, maxiter = 2000, max_pass = 20, s = 8)\n\nfem_domain.globalfield.converge_tol = 1e-6\nfem_domain.globalfield.x .= 0\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\ndx = L_box/e_number\nerr_scale = 0.05 * dx\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nfront_cp_IDs = findall((cpts.x2 .> - err_scale) .& (cpts.x2 .< err_scale * dx) .& cpts.is_occupied)\ncpts.Te[front_cp_IDs] .= 300\n\ncounter = 0\nfem_domain.globalfield.dt = 1\nwhile true\n    counter += 1\n\n    wp = fem_domain.workpieces[1]\n    write_VTK(\"$(@__DIR__)\\\\history\\\\3D_MetaFEM_Result_$counter.vtk\", wp; scale = 100, shift_sym = :d)\n\n    update_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain, max_iter = 3)\n    dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n    println(\"-------------------------$counter-----------------\")\n    Ttmax = maximum(abs.(cpts.T_t))\n    umax = maximum(abs.(cpts.d2_t))\n    (umax < 1e-4) && (Ttmax < 1e-2) && break\nend\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"","category":"page"},{"location":"examples/md/thermal_elasticity/thermal_elasticity/","page":"Thermal-hypoelasticity driven beam bending.","title":"Thermal-hypoelasticity driven beam bending.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cantilever/cantilever.jl\"","category":"page"},{"location":"examples/md/cantilever/cantilever/#Linear-elastic-cantilever-bending","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"In this example we simulate a cantilever beam under different loads, as a straightforward check on the elasticity formulation by comparison to the analytical solutions. The source with data/visualization can also be found here.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using MetaFEM\ninitialize_Definitions!()\nfem_domain = FEM_Domain(dim = 3)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Geometry","page":"Linear elastic cantilever bending","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"For cuboid geometry we have helper functions \"make_Square\"/\"make_Brick\" for 2D/3D:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"L_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvert, connections = make_Brick(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Defining boundary can be a little lengthy because we need to find those IDs. Any idea for improvement will be very welcomed.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary!(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary!(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top); fem_domain = fem_domain) #bottom & right & front free\nback_bg_ID = add_Boundary!(wp_ID, facet_IDs_back; fem_domain = fem_domain) #back will be loaded\nright_bg_ID = add_Boundary!(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded","category":"page"},{"location":"examples/md/cantilever/cantilever/#Physics","page":"Linear elastic cantilever bending","title":"Physics","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The mathematical formulation is:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"textvariablequad d_iqquadtextparametersquad Enud^w_isigma^l_ijtau","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"lambda=fracEnu(1+nu)(1-2nu)qquadmu=fracE2(1+nu)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"epsilon_ij=fracd_ij+d_ji2qquadsigma_ij=lambdadelta_ijepsilon_mm+2muepsilon_ij","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"-(d_ijsigma_ij)=0qquad inquadOmega","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_isigma^l_ijn_j)=0qquad onquad(partialOmega)_load","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_itau(d^w_i-d_i))=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"where d_iEnulambdamuepsilon_ijsigma_ij are the displacement, Young’s modulus, Poisson ratio, Lame's first parameter, shear modulus, strain and stress, respectively.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The code is: (Note, if we set the Poisson ratio ν = 0.0, the spherical part, i.e., λ related terms, will be actaully removed by the simplification.)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Δx = L_box / e_number\nE = 1\nν = 0.001\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (σ², CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\nWF_domain = Elastrostatic_Domain\n@Def begin\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n\n    WF_right_bdy = Bilinear(d{i}, σˡ{i,j} * n{j})\n    WF_back_bdy = Bilinear(d{i}, σ²{i,j} * n{j})\nend\n\nassign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, back_bg_ID, WF_back_bdy; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Assembly","page":"Linear elastic cantilever bending","title":"Assembly","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"initialize_LocalAssembly!(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Run","page":"Linear elastic cantilever bending","title":"Run","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"We run for three different loading conditions with the direct CPU LU solver for simplicity. For elasticity, most iterative solvers (with the default right Jacobi preconditioner) are stable:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables!(; fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ndx = L_box/e_number\nh, l = L_box, (L_box * LW_ratio)\nI = 1/12 * h ^ 3\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nhorizontal_mid_cp_IDs = findall((cpts.x2 .> L_box / 2 - err_scale * dx) .& (cpts.x2 .< L_box / 2 + err_scale * dx) .&\n                                (cpts.x3 .> L_box / 2 - err_scale * dx) .& (cpts.x3 .< L_box / 2 + err_scale * dx))\n\nx_plot = cpts.x1[horizontal_mid_cp_IDs] |> collect\nsorted_ids = sortperm(x_plot)\n\nhorizontal_mid_cp_IDs = horizontal_mid_cp_IDs[MetaFEM.cu(sorted_ids)]\nx_plot = x_plot[sorted_ids]\ny_plots = [[] for i = 1:2]\nplot_labels = [String[] for i = 1:2]\n\nσ_external = 1e6\ncpts.σˡ6 .= σ_external\ncpts.σ²2 .= 0\n\nupdate_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external * L_box/(6 * E * I) * (3 * l .-  x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Concentrated load, analytical\")\npush!(plot_labels[2], \"Concentrated load, MetaFEM\")\n\ncpts.σˡ6 .= 0\ncpts.σ²2 .= σ_external\n\nupdate_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (24 * E * I) * (x_plot.^2 .+ 6 * l ^ 2 .- 4 * l .* x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Uniform pressure, analytical\")\npush!(plot_labels[2], \"Uniform pressure, MetaFEM\")\n\ncpts.σ²2 .= σ_external .* (1. .- cpts.x1 ./ (L_box * LW_ratio))\n\nupdate_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (120 * l * E * I) * (10 * l ^ 3 .- 10 * l^2 .* x_plot .+ 5 * l * x_plot .^ 2 .- x_plot .^ 3) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Linearly distributed pressure, analytical\")\npush!(plot_labels[2], \"Linearly distributed pressure, MetaFEM\")","category":"page"},{"location":"examples/md/cantilever/cantilever/#Plot","page":"Linear elastic cantilever bending","title":"Plot","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"With Plots.jl:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using Plots\nfig = plot(; size=(800,800), title = \"Normalized deflection on the line y = z = 0.5\", xlims = (-1., 11.), xticks = 0:2:10, ylims = (-0.1, 1.1), yticks = 0:0.2:1, xlabel = \"x\", ylabel = \"Normalized d₂\")\nfor i = 1:3\n    color_val = (i / 3 + 1) / 2\n    scatter!(fig, x_plot, y_plots[1][i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = plot_labels[1][i])\n    plot!(fig, x_plot, y_plots[2][i], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = plot_labels[2][i])\nend\nfig.subplots[1].attr[:legend_position] = (0.2, 0.8)\npng(fig, joinpath(@__DIR__, \"3D_Cantilever_Plots.png\"))","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(Image: cantilever)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/lid_driven_cavity/lid_driven_cavity.jl\"","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Lid-driven-cavity","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Lid-driven cavity is perhaps the most well-known example in CFD like hello-world.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"(Image: cavity_flow)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The streamline is the Re = 1000 case and visualized in Paraview. The full source/data/visualization is here.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using MetaFEM\nusing CSV, DataFrames\ninitialize_Definitions!()\n\ndim = 2\nfem_domain = FEM_Domain(dim = dim)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Geometry","page":"Lid-driven cavity","title":"Geometry","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"L_box, e_number = 1., 40\ndomain_size = (L_box, L_box)\nelement_number = (e_number, e_number)\nelement_shape = :CUBE\n\nvert, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Boundary","page":"Lid-driven cavity","title":"Boundary","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = L_box / e_number * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L_box .+ err_scale)) .& (x1_mean .> (L_box .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary!(wp_ID, vcat(sIDs_left, sIDs_bottom, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary!(wp_ID, sIDs_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Physics","page":"Lid-driven cavity","title":"Physics","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Δx = L_box / e_number\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128 # 8, 16, 32\nτᵇ = μ / ρ * Cᵇ / Δx\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n    NS_boundary_BASE = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n\n    NS_boundary_DISP = ρ * Bilinear(u{i}, (uʷ{i} * uʷ{j} - u{i} * u{j}) * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +\n                        μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_FIX = ρ * Bilinear(u{i}, - u{i} * u{j} * n{j}) + Bilinear(p, - u{i} * n{i}) +\n                      μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_top = NS_boundary_BASE + NS_boundary_DISP\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, top_bg_ID, WF_boundary_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Assemble-and-Run","page":"Lid-driven cavity","title":"Assemble & Run","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"initialize_LocalAssembly!(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\n@time begin\n    for wp in fem_domain.workpieces\n        update_Mesh(fem_domain.dim, wp, wp.element_space)\n    end\n    assemble_Global_Variables!(fem_domain = fem_domain)\n    compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\nend\n\nfem_domain.linear_solver = solver_LU_CPU # Note if we want to use an iterative solver for high Re number, many may be unstable, bicgstabl_GS! is recommanded as the most stable one, e.g.,","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = bicgstabl_GS!, maxiter = 2000, max_pass = 10, s = 8)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"fem_domain.globalfield.converge_tol = 1e-6\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\n@Takeout x1, x2, u1 FROM cpts\nis_occupied = cpts.is_occupied\ndx = L_box/e_number\n\nmid_cp_IDs = (x1 .> L_box/2 - 0.25 * dx) .& (x1 .< L_box/2 + 0.25 * dx)\nnum_y = x2[mid_cp_IDs]./L_box |> collect\nexp_us, exp_ys, num_us = [[] for i = 1:3]\nexp_labels, num_labels = [String[] for i =1:2]\n\nRe_arr = [100, 400, 1000, 3200, 5000]\nfor Re in Re_arr\n    u_st = Re / L_box * μ / ρ\n    fem_domain.globalfield.x .= 0.\n    fem_domain.globalfield.t = 0.\n    dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n    tmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\n    for i = 1:tmax\n        cpts = fem_domain.workpieces[1].mesh.controlpoints\n        cp_IDs = findall(cpts.is_occupied)\n\n        u_top = u_st * (i / tmax)\n        dt = fem_domain.globalfield.dt = 0.2 * Δx / u_top\n\n        cpts.uʷ1[cp_IDs] .= u_top\n        cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n        cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n        println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n        update_OneStep!(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n        dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n    end\n    filename = string(\"Ghia_Re\", Re, \".csv\")\n    file_data = CSV.read(joinpath(@__DIR__, filename), DataFrame)\n\n    push!(num_us, collect(u1[mid_cp_IDs] ./ u_st))\n    push!(exp_us, collect(file_data.u))\n    push!(exp_ys, collect(file_data.y))\nend","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Visualization","page":"Lid-driven cavity","title":"Visualization","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"CSV files contain Ghia's data is also in the same folder.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using Plots\nfig = plot(; size=(800,800), title = \"Horizontal Velocity on Line x = 0.5\", xticks = -0.4:0.2:1, limits = (-0.5, 1.05, -0.05, 1.05), yticks = 0.0:0.1:1, xlabel = \"Normalized U₁\", ylabel = \"y\")\nfor i = 1:length(Re_arr)\n    color_val = (i / length(Re_arr) + 1) / 2\n    ids = sortperm(num_y)\n\n    scatter!(fig, exp_us[i], exp_ys[i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = string(\"Re $(Re_arr[i]), Ghia\"))\n    plot!(fig, num_us[i][ids], num_y[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = string(\"Re $(Re_arr[i]), MetaFEM\"))\nend\nfig.subplots[1].attr[:legend_position] = (0.7, 0.3)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Save the figure as .png file.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"png(fig, joinpath(@__DIR__, \"2D_Ux_Plots.png\"))","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#VTK","page":"Lid-driven cavity","title":"VTK","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"fem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\nRe = 1000\nu_st = Re / L_box * μ / ρ\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\ntmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\nfor i = 1:tmax\n    cpts = fem_domain.workpieces[1].mesh.controlpoints\n    cp_IDs = findall(cpts.is_occupied)\n\n    u_top = u_st * (i / tmax)\n    dt = fem_domain.globalfield.dt = 0.2 * Δx / u_top\n\n    cpts.uʷ1[cp_IDs] .= u_top\n    cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n    cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n    println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n    update_OneStep!(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\nend\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"2D_Cavity_Flow.vtk\"), wp)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/J2plasticity/J2plasticity.jl\"","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#J2-hypo-elastic-plasticity-with-mixed-hardening","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"(Image: pic)","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"Plasticity involves nonlinear implicit constraints, which can't be derived by MetaFEM but we provide the interface to the native Julia. The uniaxial loading case on the same beam geometry is as follows. The source is here.","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Geometry","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Geometry","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"using MetaFEM\ninitialize_Definitions!()\n\nfem_domain = FEM_Domain(dim = 3)\nL_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvert, connections = make_Brick(domain_size, element_number, element_shape)\n@time ref_mesh = construct_TotalMesh(vert, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio .- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nleft_bg_ID = add_Boundary!(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nright_bg_ID = add_Boundary!(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Physics","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Physics","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"Note we defines the plastic strain ep as the INTEGRATION_POINT_VAR, and provide the external interface explicitly as: ep{i,j} = strain_updater(e{1,1}, e{1,2}, e{1,3}, e{2,2}, e{2,3}, e{3,3}), where the LHS specifies ep is a second order tensor and the RHS specifies how we calculate it. The rest script should be intuitive without any trick.","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"Δx = L_box / e_number\nρ = 1e3\nc = 2\nEy = 100e3\nν = 0.0\nλ = Ey * ν / ((1 + ν) * (1 - 2 * ν))\nμ = Ey / (2 * (1 + ν))\nτᵇ = 1000 * Ey / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (ep, INTEGRATION_POINT_VAR, SYMMETRIC_TENSOR)\n@Def begin\n    e{i,j} = (d{i;j} + d{j;i}) / 2\n    ep{i,j} = strain_updater(e{1,1}, e{1,2}, e{1,3}, e{2,2}, e{2,3}, e{3,3})\n    e_eval{i,j} = e{i,j} - ep{i,j}\n\n    σ{i,j} = 2 * μ * e_eval{i,j} + λ * e_eval{m,m} * δ{i,j}\n    WF_domain = Bilinear(d{i;j}, σ{i,j}) + Bilinear(d{i}, ρ * (c * d{i;t} + d{i;t,t}))\n\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (d{i} - dʷ{i}))\n    WF_right_bdy = Bilinear(d{i}, - σˡ{i,j} * n{j})\nend\n\n@time begin\n    assign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, left_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\n    assign_Boundary_WeakForm!(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nend\ninitialize_LocalAssembly!(fem_domain)","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Assembly","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Assembly","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"@time mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\n@time begin\n    update_Mesh(fem_domain.dim, fem_domain.workpieces[1], fem_domain.workpieces[1].element_space)\n    assemble_Global_Variables!(; fem_domain = fem_domain)\nend","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Define-External-Strain-Updater","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Define External Strain Updater","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"mutable struct MaterialState{ArrayType}\n    ep_eval::Vector{ArrayType}\n    b_eval::Vector{ArrayType}\n    Y_eval::ArrayType\n\n    ep::Vector{ArrayType}\n    b::Vector{ArrayType} #db = \\alpha dσ\n    Y::ArrayType\n\n    λ::FEM_Float\n    μ::FEM_Float\n    Eb::FEM_Float\n    Ep::FEM_Float\n\n    f_res::FEM_Float\n\n    function MaterialState{ArrayType}(sz::Tuple, Y_initial, params...) where ArrayType\n        ep_eval = [FEM_zeros(ArrayType, FEM_Float, sz...) for i = 1:6]\n        b_eval = [FEM_zeros(ArrayType, FEM_Float, sz...) for i = 1:6]\n        Y_eval = FEM_zeros(ArrayType, FEM_Float, sz...)\n\n        ep = [FEM_zeros(ArrayType, FEM_Float, sz...) for i = 1:6]\n        b = [FEM_zeros(ArrayType, FEM_Float, sz...) for i = 1:6]\n        Y = FEM_zeros(ArrayType, FEM_Float, sz...)\n        Y .= Y_initial\n        return new{ArrayType}(ep_eval, b_eval, Y_eval, ep, b, Y, params...)\n    end\n\n    function MaterialState(wp::WorkPiece{ArrayType}, args...) where ArrayType\n        integration_number = size(wp.mesh.elements.integral_vals, 1)\n        element_number = sum(wp.mesh.elements.is_occupied)\n        return MaterialState{ArrayType}((integration_number, element_number), args...)\n    end\nend\n\nfunction (state::MaterialState)(e1_1, e1_2, e1_3, e2_2, e2_3, e3_3)\n    e_test_tensor = assemble_strain(e1_1, e1_2, e1_3, e2_2, e2_3, e3_3)\n    iterate_stress!(state, e_test_tensor)\n    return state.ep_eval\nend\n\nvoigt_ID(i,j) = Voigt_ID(i,j,3)\nfunction assemble_strain(e1_1, e1_2, e1_3, e2_2, e2_3, e3_3)\n    e_test_tensor = Vector{Any}(undef, 6)\n    e_test_tensor[voigt_ID(1, 1)] = e1_1\n    e_test_tensor[voigt_ID(2, 2)] = e2_2\n    e_test_tensor[voigt_ID(3, 3)] = e3_3\n    e_test_tensor[voigt_ID(1, 2)] = e1_2\n    e_test_tensor[voigt_ID(1, 3)] = e1_3\n    e_test_tensor[voigt_ID(2, 3)] = e2_3\n    return e_test_tensor\nend\n\nfunction estimate_stress(state::MaterialState, e_tensor)\n    @Takeout (λ, μ) FROM state\n    sigma_tensor = Vector{Any}(undef, 6)\n    for i = 1:3, j = i:3\n        sigma_tensor[voigt_ID(i, j)] = (2 * μ) .* e_tensor[voigt_ID(i, j)]\n    end\n\n    for i = 1:3\n        sigma_tensor[voigt_ID(i, i)] .+= λ .* (e_tensor[voigt_ID(1, 1)] .+ e_tensor[voigt_ID(2, 2)] .+ e_tensor[voigt_ID(3, 3)])\n    end\n    return sigma_tensor\nend\n\nfunction iterate_stress!(state::MaterialState{ArrayType}, e_test_tensor) where ArrayType\n    @Takeout (ep_eval, b_eval, Y_eval, ep, b, Y, λ, μ, Eb, Ep, f_res) FROM state\n\n    e_eval_tensor = Vector{Any}(undef, 6)\n    for i = 1:6\n        ep_eval[i] .= ep[i]\n        e_eval_tensor[i] = e_test_tensor[i] .- ep_eval[i]\n        b_eval[i] .= b[i]\n    end\n\n    Y_eval .= Y\n    λp = FEM_buffer(ArrayType, FEM_Float, size(Y)...)\n    sigma_tensor = estimate_stress(state, e_eval_tensor)\n\n    s_dev_2 = FEM_buffer(ArrayType, FEM_Float, size(Y)...)\n    skk_div3 = FEM_buffer(ArrayType, FEM_Float, size(Y)...)\n    s_dev_mag = FEM_buffer(ArrayType, FEM_Float, size(Y)...)\n\n    s_dev_tensor = Vector{Any}(undef, 6)\n    n_dev_tensor = Vector{Any}(undef, 6)\n\n    for i = 1:6\n        s_dev_tensor[i] = sigma_tensor[i] .- b_eval[i]\n    end\n    skk_div3 = (s_dev_tensor[voigt_ID(1, 1)] .+ s_dev_tensor[voigt_ID(2, 2)] .+ s_dev_tensor[voigt_ID(3, 3)]) ./ 3\n\n    for i = 1:3\n        s_dev_tensor[voigt_ID(i, i)] .-= skk_div3 #now s becomes dev(s)\n    end\n\n    for i = 1:3, j = 1:3\n        s_dev_2 .+= s_dev_tensor[voigt_ID(i, j)] .* s_dev_tensor[voigt_ID(i, j)]\n    end\n    s_dev_mag .= sqrt.(s_dev_2)\n    for i = 1:6\n        n_dev_tensor[i] = s_dev_tensor[i] ./ s_dev_mag\n    end\n    f = sqrt(3 / 2) .* s_dev_mag .- Y_eval  #yield criteria!\n    yielded_IDs = findall(f .> f_res)\n    if ~isempty(yielded_IDs)\n        λp[yielded_IDs] .=  sqrt(3 / 2) .* f[yielded_IDs] ./ (3 * μ + Eb + Ep)\n        println(\"yielded\")\n        for i = 1:6\n            ep_eval[i][yielded_IDs] .= ep[i][yielded_IDs] .+ n_dev_tensor[i][yielded_IDs] .* λp[yielded_IDs]\n            b_eval[i][yielded_IDs] .= b[i][yielded_IDs] .+ (2 / 3 * Eb) .* n_dev_tensor[i][yielded_IDs] .* λp[yielded_IDs]\n        end\n        Y_eval[yielded_IDs] .= Y[yielded_IDs] .+ (sqrt(2/3) * Ep) .* λp[yielded_IDs]\n    end\n    return nothing\nend\n\nfunction update_States!(state::MaterialState)\n    for i = 1:6\n        state.ep[i] .= state.ep_eval[i]\n        state.b[i] .= state.b_eval[i]\n    end\n    state.Y .= state.Y_eval\n    return nothing\nend\n\nY_initial = 100\nf_res = 1\nEb = 0\nEp = Ey / 2\nstrain_updater = MaterialState(fem_domain.workpieces[1], Y_initial, λ, μ, Eb, Ep, f_res)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Run-and-Gather-Data","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Run & Gather Data","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = bicgstabl_GS!, maxiter = 2000, max_pass = 20, s = 8)\nfem_domain.globalfield.converge_tol = 1e-3\n\nd1_data = Vector[]\n\ns_test_groups = [[40, 80, 100, 120, 140, 180, 200, 180, 100, 0, -80, -180, -200, -220, -240, -200, -100],\n                 [40, 80, 100, 120, 140, 180, 200, 180, 100, 0, -80, -100, -120, -160, -100],\n                 [40, 80, 100, 120, 140, 180, 200, 180, 140, 100, 80, 40, 0, -40, -100, -80, -20]]\nd1_analytical = [[4, 8, 10, 16, 22, 34, 40, 38, 30, 20, 12, 2, 0, -6, -12, -8, 2] .* 1e-3,\n                 [4, 8, 10, 16, 22, 34, 40, 38, 30, 20, 12, 10, 4, -8, -2].* 1e-3,\n                 [4, 8, 10, 16, 22, 34, 40, 38, 34, 30, 28, 24, 20, 8, -10, -8, -2].* 1e-3]\n\nEb_groups = [0, Ey / 4, Ey / 2]\nEp_groups = [Ey / 2, Ey / 4, 0]\n\ndx = L_box/e_number\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\neles = fem_domain.workpieces[1].mesh.elements\nright_cp_IDs = findall((cpts.x1 .> (L_box * LW_ratio) - err_scale * dx) .& (cpts.x1 .< (L_box * LW_ratio) + err_scale * dx))\nleft_cp_IDs = findall((cpts.x1 .> - err_scale * dx) .& (cpts.x1 .< err_scale * dx))\n\ndt = fem_domain.globalfield.dt = 1e0 # viscousity\n\nfor (s_tests, Eb, Ep) in zip(s_test_groups, Eb_groups, Ep_groups)\n    d1s = FEM_Float[]\n\n    cpts.d1 .= 0\n    cpts.d2 .= 0\n    cpts.d3 .= 0\n    cpts.d1_t .= 0\n    cpts.d2_t .= 0\n    cpts.d3_t .= 0\n    cpts.d1_tt .= 0\n    cpts.d2_tt .= 0\n    cpts.d3_tt .= 0\n\n    assemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n    for i = 1:6\n        strain_updater.ep[i] .= 0\n        strain_updater.b[i] .= 0\n    end\n    strain_updater.Y .= Y_initial\n    strain_updater.Eb = Eb\n    strain_updater.Ep = Ep\n    for s in s_tests\n        cpts.σˡ1 .= s\n        counter = 0\n        while true\n            counter += 1\n            update_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain, max_iter = 3)\n            dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n            println(\"-------------------------$counter-----------------\")\n            update_States!(strain_updater)\n            umax = maximum(abs.(cpts.d1_t))\n            println(\"umax = $umax\")\n            if (umax < 1e-4)\n                println(counter)\n                push!(d1s, sum(cpts.d1[right_cp_IDs]) / prod(size(right_cp_IDs)))\n                break\n            end\n        end\n    end\n    push!(d1_data, d1s)\nend","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/#Plot","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"Plot","text":"","category":"section"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"using Plots\nfig = plot(; size = (900,800), title = \"Uniaxial loading on J2-flow hypoelastic-plastic materials.\" , xlims = (-0.015, 0.045), xticks = -0.01:0.01:0.04, ylims = (-250, 210), xlabel = \"Elongation\", ylabel = \"Nominal stress (MPa)\")\ncase_num = length(s_test_groups)\nfor (i, (s_tests, d1_ana, d1s, Eb, Ep)) in enumerate(zip(s_test_groups, d1_analytical, d1_data, Eb_groups, Ep_groups))\n    color_val = (i / case_num + 1) / 2\n\n    scatter!(fig, d1s, s_tests, markershape = :circle, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = \"numerical, Eb = $(Eb / 1e3) GPa, Ep = $(Ep / 1e3) GPa\")\n    plot!(fig, d1_ana, s_tests, color = RGBA(0, 0.5, color_val, 1), label = \"analytical, Eb = $(Eb / 1e3) GPa, Ep = $(Ep / 1e3) GPa\")\nend\nfig.subplots[1].attr[:legend_position] = (0.15, 0.9)\nfig","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"","category":"page"},{"location":"examples/md/J2plasticity/J2plasticity/","page":"J2 hypo-elastic-plasticity with mixed hardening","title":"J2 hypo-elastic-plasticity with mixed hardening","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Core","page":"APIs","title":"Core","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"MetaFEM has three basic data structures:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"FEM_Domain, the overall system, defines Kx=d.\nWorkPiece, a mesh assigned with physics, defines both domain physics and other numerical modifications like stabilization.\nBoundary, an array of segment/face IDs assigned with physics, defines boundary condition.","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    FEM_Domain\r\n    MetaFEM.WorkPiece\r\n    add_Boundary!","category":"page"},{"location":"api/#MetaFEM.FEM_Domain","page":"APIs","title":"MetaFEM.FEM_Domain","text":"FEM_Domain\n\nA FEM_Domain contains everything needed to assemble a linear system Kx=d in FEM. The attributes are:\n\ndim, the dimension, 2 or 3.\nworkpieces, the array of all the WorkPieces in this domain, which will be finally solved in fully coupling.\ntools, reserved for the external geometry Tool, e.g., for contact. Not implemented.\ntime_discretization, the temporal discritization scheme. Currently only generalized-α method is implemented.\nglobalfield, the container for sparse K, dense x and d in Kx=d.\nK_linear_func the generated function to update the linear part of K.\nK_nonlinear_func the generated function to update the nonlinear part of K and the residue d.\nlinear_solver, the applied linear solver.\n\nTo add a FEM_Domain of dimension dim, the exposed API is:\n\nFEM_Domain(; dim::Integer)\n\nwhich returns the new FEM_Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaFEM.WorkPiece","page":"APIs","title":"MetaFEM.WorkPiece","text":"WorkPiece\n\nA WorkPiece is a meshed part assigned with some known physics. The attributes are:\n\nref_geometry, the first order mesh to describe the FEM_Geometry.\nphysics, the raw PDE weakforms.\nlocal_assembly, the re-organized PDE weakforms with sorted/indexed variables.\nmax_sd_order, an explicit limit of the maximum spatial derivative order to save memory.\nelement_space, the information about the spatial discritization, i.e., interpolation and intergration.\nmesh, the mesh regenerated according to the element_space and actually used in simulation.\n\nTo add a Workpiece with the geometry ref_geometry to the FEM_Domain fem_domain, the exposed API is:\n\nadd_WorkPiece!(ref_geometry; fem_domain::FEM_Domain)\n\nwhich returns the WorkPiece ID in the fem_domain.workpieces.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaFEM.add_Boundary!","page":"APIs","title":"MetaFEM.add_Boundary!","text":"add_Boundary!(ID::Integer, bdy_ref_edge_IDs::CuVector; fem_domain::FEM_Domain = fem_domain, target::Symbol = :WorkPiece)\n\nIn a 2D/3D FEM_Domain fem_domain, mark the segment/face IDs of the WorkPiece fem_domain.workpieces[wp_ID] as a boundary, to assign physics later. Multiple boundaries are independent from each other and can share the same segment/face IDs. If target = :Tool, the boundary is of fem_domain.tools[wp_ID], not implemented.\n\nThe function returns the boundary group ID bg_ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mesh","page":"APIs","title":"Mesh","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"The input to define a mesh is (vert, connections), very similar to the mesh loading process in other fields, e.g., for plotting","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"vert is a dim times N_n CuArray of coordinates, where N_n is the number of nodes.\nconnections is a N_v times N_e CuArray of sequenced node IDs where N_v is the number of nodes in each element and N_e is the total element number.","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"To define (vert, connections), we have the following helper functions:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    make_Square\r\n    read_Mesh","category":"page"},{"location":"api/#MetaFEM.make_Square","page":"APIs","title":"MetaFEM.make_Square","text":"make_Square(x::Tuple, n::Tuple, shape = :CUBE)\nmake_Brick(x::Tuple, n::Tuple, shape = :CUBE)\n\nHelper functions to creates a grid, i.e., the mesh nodes are positioned at cubic lattice points, with mesh shape = :CUBE or :SIMPLEX defining the connections.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.read_Mesh","page":"APIs","title":"MetaFEM.read_Mesh","text":"read_Mesh(filename::String)\n\nThe function loads an external mesh. Currently supported file types are:\n\n.inp file, Abaqus first order mesh.\n.mphtxt file, COMSOL mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"With (vert, connections), the first order mesh can be defined by:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    construct_TotalMesh","category":"page"},{"location":"api/#MetaFEM.construct_TotalMesh","page":"APIs","title":"MetaFEM.construct_TotalMesh","text":"construct_TotalMesh(coors, connections)\nconstruct_TotalMesh(::Type{ArrayType}, coors, connections)\n\nThe function reads (vert, connections) and declares the first order mesh, FEM_Geometry.  If not explicitly declared, the defualt ArrayType is DEFAULT_ARRAYINFO._type, which is GPU_DeviceArray if unspecified.\n\nThere are 4 concepts in a FEM_Geometry:\n\nEach vertex in vertices stores the vertex coordinates.\nEach segment in segments stores the vertex IDs connected to this segment.\nEach face in faces stores both the vertex IDs and the segment IDs connected to this face.\nEach block in blocks stores the vertex IDs, the segment IDs and the face IDs connected to this block.\n\nIf applicable, the IDs are in order, e.g., segment IDs in a face are clockwise/counter-clockwise (since we can't define an outward normal for a bare face).\n\nThe function returns either a Geo_TotalMesh2D with attributes (vertices, segments, faces) or a  Geo_TotalMesh3D with attributes (vertices, segments, faces, blocks).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"We also have the helper function to define boundaries:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    get_BoundaryMesh","category":"page"},{"location":"api/#MetaFEM.get_BoundaryMesh","page":"APIs","title":"MetaFEM.get_BoundaryMesh","text":"get_BoundaryMesh(total_mesh::Geo_TotalMesh2D)\nget_BoundaryMesh(total_mesh::Geo_TotalMesh3D)\n\nHelper function to collect all the segment/face IDs which can be marked as boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#Symbolics","page":"APIs","title":"Symbolics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"The APIs to define the physics are pretty straightforward:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    @Sym\r\n    @Def\r\n    assign_Boundary_WeakForm!\r\n    visualize","category":"page"},{"location":"api/#MetaFEM.@Sym","page":"APIs","title":"MetaFEM.@Sym","text":"@Sym (name, attribute_1, attribute_2,...)\n@External_Sym (name, attribute_1, attribute_2,...)\n\n@Sym declares a variable symbol name with the attributes attribute_1, attribute_2, ...,  which is simply stored as the pair name => (attribute_1, attribute_2, ...) in the exposed global dictionary VARIABLE_ATTRIBUTES.\n\n@External_Sym is just the @Sym with one default attribute: :EXTERNAL_VAR.\n\n\n\n\n\n","category":"macro"},{"location":"api/#MetaFEM.@Def","page":"APIs","title":"MetaFEM.@Def","text":"@Def ex \n@Def begin\n    ex1\n    ex2\n    ...\nend\n\n@Def defines a symbolic term, e.g., 1, σ{i, j}`, Bilinear(⋅, ⋅), etc.\n\n\n\n\n\n","category":"macro"},{"location":"api/#MetaFEM.assign_Boundary_WeakForm!","page":"APIs","title":"MetaFEM.assign_Boundary_WeakForm!","text":"assign_WorkPiece_WeakForm!(wp_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)\nassign_Boundary_WeakForm!(wp_ID::Integer, bg_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)\n\nThe functions assign this_term, which is either a bilinear term Bilinear(⋅, ⋅), or a sum of the bilinear terms, to the target WorkPiece or boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.visualize","page":"APIs","title":"MetaFEM.visualize","text":"visualize(x::Union{SymbolicWord, SymbolicTerm, SubtermVariable, FunctionVariable, RewritingRule, Symbolic_BilinearForm, Symbolic_WeakForm})\n\nPrint the expressions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Assembly","page":"APIs","title":"Assembly","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"There are some necessary preprocesses:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    initialize_LocalAssembly!\r\n    mesh_Classical\r\n    compile_Updater_GPU","category":"page"},{"location":"api/#MetaFEM.initialize_LocalAssembly!","page":"APIs","title":"MetaFEM.initialize_LocalAssembly!","text":"initialize_LocalAssembly!(fem_domain::FEM_Domain; explicit_max_sd_order::Integer = 9)\ninitialize_LocalAssembly!(dim::Integer, workpieces::Vector{WorkPiece}; explicit_max_sd_order::Integer = 9)\n\nThis function preprocesses/reorganizes the weakforms. The input explicit_max_sd_order is the exposed API for  explicitly limit high order spatial derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.mesh_Classical","page":"APIs","title":"MetaFEM.mesh_Classical","text":"mesh_Classical(wp_IDs; shape::Symbol, itp_type::Symbol = :Lagrange, itp_order::Integer, itg_order::Integer, fem_domain::FEM_Domain)\n\nThe function generates the mesh of order itp_order, interpolation type itp_type = :Lagrange/:Serendipity with gaussian quadrature of order itg_order on fem_domain.workpieces[wp_IDs]. The dimension and mesh type (:CUBE/:SIMPLEX) will follow the first order mesh of each WorkPiece.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.compile_Updater_GPU","page":"APIs","title":"MetaFEM.compile_Updater_GPU","text":"compile_Updater_GPU(; domain_ID::Integer, fem_domain::FEM_Domain)\n\nThe function generates fem_domain.K_linear_func and fem_domain.K_nonlinear_func. The input domain_ID is only used to generate the function name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-simulation","page":"APIs","title":"Update simulation","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"    update_Mesh\r\n    assemble_Global_Variables!\r\n    update_OneStep!\r\n    assemble_X!\r\n    dessemble_X!","category":"page"},{"location":"api/#MetaFEM.update_Mesh","page":"APIs","title":"MetaFEM.update_Mesh","text":"update_Mesh(dim::Integer, wp::WorkPiece, this_space::Classical_Discretization)\n\nThis function updates Jacobians and interpolation values.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.assemble_Global_Variables!","page":"APIs","title":"MetaFEM.assemble_Global_Variables!","text":"assemble_Global_Variables!(; fem_domain::FEM_Domain)\n\nThis function allocates the sparse K, dense x and d.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.update_OneStep!","page":"APIs","title":"MetaFEM.update_OneStep!","text":"update_OneStep!(time_discretization::GeneralAlpha; max_iter::Integer = 4, fem_domain::FEM_Domain)\n\nThis function calculates K(Δx)=d and updates x += (Δx). max_iter determines the maximum iteration for Δx with different K and d in nonlinear cases. The converge tolerance is determined by fem_domain.globalfield.converge_tol while the linear solver is fem_domain.linear_solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.assemble_X!","page":"APIs","title":"MetaFEM.assemble_X!","text":"assemble_X!(workpieces::Vector{WorkPiece}, globalfield::GlobalField)\n\nThis function assembles/synchronizes local data to globalfield.x, i.e., to setup the initial values for some workpiece.mesh.controlpoint.sym, like workpiece.mesh.controlpoint.T.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.dessemble_X!","page":"APIs","title":"MetaFEM.dessemble_X!","text":"dessemble_X!(workpieces::Vector{WorkPiece}, globalfield::GlobalField)\n\nThis function dessembles globalfield.x to local data, i.e., for ploting some workpiece.mesh.controlpoint.sym, like workpiece.mesh.controlpoint.T.\n\n\n\n\n\n","category":"function"},{"location":"api/#Linear-solvers","page":"APIs","title":"Linear solvers","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"In update_OneStep, the linear solver, fem_domain.linear_solver is called, which is supposed to take a globalfield and return the dx. We provide the following linear solvers:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    solver_LU_CPU\r\n    solver_QR_GPU\r\n    solver_LU_GPU\r\n    iterative_Solve!\r\n    bicgstabl!\r\n    bicgstabl_GS!\r\n    idrs!\r\n    idrs_original!\r\n    gmres!\r\n    lsqr!\r\n    cgs!","category":"page"},{"location":"api/#MetaFEM.solver_LU_CPU","page":"APIs","title":"MetaFEM.solver_LU_CPU","text":"solver_LU_CPU(globalfield)\n\nCPU LU solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_QR_GPU","page":"APIs","title":"MetaFEM.solver_QR_GPU","text":"solver_QR_GPU(globalfield; reorder::Integer = 1, singular_tol::Number)\n\nGPU QR solver with CUDA's csrlsvqr!.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_LU_GPU","page":"APIs","title":"MetaFEM.solver_LU_GPU","text":"solver_LU_CPU(globalfield; reorder::Integer = 1, singular_tol::Number)\n\nGPU LU solver with CUDA's csrlsvlu!. Note, csrlsvlu! is essentially a host function and the device part is not accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.iterative_Solve!","page":"APIs","title":"MetaFEM.iterative_Solve!","text":"iterative_Solve!(globalfield::GlobalField; Sv_func!::Function = bicgstabl_GS!, Pr_func!::Function = Pr_Jacobi!, Pl_func::Function = Identity, max_pass = 4, kwargs...)\n\nWrapper of general iterative solvers, where:\n\nSv_func! is the detailed iterative solver to be called with the folloiwng choices:\nBICG family: bicgstabl_GS!, bicgstabl!`\nIDRS family: idrs!, idrs_original! \nLSQR: lsqr!\nGMRES: gmres! \nPr_func is the right preconditioner function with the following choices:\nIdentity: do nothing.\nPr_Jacobi (default): normalize each column by the diagnal element or the column norm. \nPl_func is the left preconditioner function with the following choices:\nIdentity (default): do nothing.\nPl_Jacobi: normalize each row by the diagnal element or the row norm. \nPl_ILU: ILU preconditioner provided by ilu02! in CUDA.jl.\nmax_pass is the number of attempts in one solving step, e.g., let max_pass = 4 and let maxiter = 3000 in idrs!, then the solver will run 4 (restarted) batches of 3000 iterations in solving every Kx=d.\nOther kwargs... will be passed into Sv_func! as keyword arguments.\n\nNote, by default the iterative solver will be right Jacobi preconditioned only.  A right preconditioner modifies the matrix once when the solver begins and modifies the x once when the solver exits, i.e.,  roughly cost one more mat-vec mul!(mv!) and one more vec-vec axpy!. The right preconditioner will both ameliorate the numerical inaccuracy and reduce the iteration number from the ill-conditioning.\n\nA left preconditioner modifies the vector every time a mat-vec mul! occurs, and it can only reduce the iteration number but not ameliorate the (condition number induced) numerical inaccuracy. However, left preconditioner can be more complicated, e.g., ILU, than the right preconditioner, for which only Jacobi can be practically applied when the matrix is large (in author's limited knowledge).\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.bicgstabl!","page":"APIs","title":"MetaFEM.bicgstabl!","text":"bicgstabl!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 2, kwargs...)\n\nbicgstabl, a classical stablized bi conjugate gradient method, adapted from IterativeSolvers.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.bicgstabl_GS!","page":"APIs","title":"MetaFEM.bicgstabl_GS!","text":"bicgstabl_GS!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 2, kwargs...)\n\nbicgstabl, a classical stablized bi conjugate gradient method, where the \"GS\" suffix means using Gram-Schmidt instead of LU to solve the minimal residual part,  empirically more numerical stable.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.idrs!","page":"APIs","title":"MetaFEM.idrs!","text":"idrs!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 4, kwargs...)\n\nIDRs (induced dimension reduction) solver, adapted from IterativeSolvers.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.idrs_original!","page":"APIs","title":"MetaFEM.idrs_original!","text":"idrs_original!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s::Integer = 4, kwargs...)\n\nIDRs (induced dimension reduction) solver, where the \"original\" suffix is the earlier version doing direct orthogonalization without exploit orthogonality incrementally.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.gmres!","page":"APIs","title":"MetaFEM.gmres!","text":"gmres!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s = 20, kwargs...)\n\nVanilla GMRES solver which restarts every s = 20 iteration. GMRES may enter early stagnation and leave with large residue/error.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.lsqr!","page":"APIs","title":"MetaFEM.lsqr!","text":"lsqr!(x, A, b; Pl = Identity(), tol::Real, maxiter::Integer, s = 20, kwargs...)\n\nLSQR solver, robust over most matrices, e.g., the ones generated randomly by sprand, where solvers like IDRs may explode. However, IDRs/... may converge much faster than LSQR when stable.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"with the following preconditioners:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    Identity\r\n    Pr_Jacobi!\r\n    Pl_Jacobi\r\n    Pl_ILU","category":"page"},{"location":"api/#MetaFEM.Identity","page":"APIs","title":"MetaFEM.Identity","text":"Identity(args...; kwargs...)\n\nReturns an identity preconditioner, i.e., do nothing at all.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.Pr_Jacobi!","page":"APIs","title":"MetaFEM.Pr_Jacobi!","text":"Pr_Jacobi!(A::CuSparseMatrixCSR{T}; normalized_by_column = false)\n\nGPU Jacobi right preconditioner. Each column of the matrix will be normalized, if normalized_by_column = false by the diagonal element, otherwise, by the column norm. \n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.Pl_Jacobi","page":"APIs","title":"MetaFEM.Pl_Jacobi","text":"Pl_Jacobi(A::CuSparseMatrixCSR{T}; normalized_by_row = false)\n\nGPU Jacobi left preconditioner. Each row of the matrix will be normalized through modifying the final residue vector instead of the matrix, if normalized_by_row = false, by the diagonal element, otherwise, by the row norm. \n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.Pl_ILU","page":"APIs","title":"MetaFEM.Pl_ILU","text":"Pl_ILU(A)\n\nGPU ILU preconditioner with CUDA's ilu02!.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"where the prefix Pl denotes left preconditioners while the prefix Prdenotes right preconditioners. ","category":"page"},{"location":"api/#Other-helper-functions","page":"APIs","title":"Other helper functions","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"    write_VTK\r\n    @Takeout\r\n    MEM_UNIT","category":"page"},{"location":"api/#MetaFEM.write_VTK","page":"APIs","title":"MetaFEM.write_VTK","text":"write_VTK(fname::String, wp::WorkPiece; scale = 1.)\n\nOutput all the variables in WorkPiece wp to file fname. The scale is only for the length scale, i.e., node coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.@Takeout","page":"APIs","title":"MetaFEM.@Takeout","text":"@Takeout a, b FROM c\n\nequals to\n\na = c.a\nb = c.b\n\nwhile\n\n@Takeout a, b FROM c WITH PREFIX d\n\nequals to\n\nda = c.a\ndb = c.b\n\n\n\n\n\n","category":"macro"},{"location":"api/#MetaFEM.MEM_UNIT","page":"APIs","title":"MetaFEM.MEM_UNIT","text":"MEM_UNIT(unit_name::String)\n\nSet the displayed memory unit where unit_name can be \"B\", \"KB\", \"MB\", \"GB\", \"TB\".\n\n\n\n\n\n","category":"constant"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cylinderflow/cylinderflow.jl\"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Incompressible-flow-pass-a-cylinder","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"In this example we simulate a flow case like this (Image: flow) First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"using MetaFEM\ninitialize_Definitions!()\ndim = 3\nfem_domain = FEM_Domain(; dim = dim)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Geometry","page":"Incompressible flow pass a cylinder","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Load the mesh \"3D_COMSOL_Mesh.mphtxt\" which can be found in here and should be put under the same directory of the script.","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"L = 2.5\nH = 0.41\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Define boundary:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = 0.01\n\nis_left = (x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))\nis_right = (x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary!(wp_ID, facet_IDs[.~(is_left .| is_right)]; fem_domain = fem_domain)\ninflow_bg_ID = add_Boundary!(wp_ID, facet_IDs[is_left]; fem_domain = fem_domain)\noutflow_bg_ID = add_Boundary!(wp_ID, facet_IDs[is_right]; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Physics","page":"Incompressible flow pass a cylinder","title":"Physics","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"The steady state Navier-Stokes (NS) equation with Streamline-Upwind/Peterove-Galerkin (SUPG) stabilization can be formed as follows:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"textvariablequad u_ipqquadtextparametersquadrhomuu^W_itau^btau^ctau^m","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Rccoloneqq u_kkqquad Rm_icoloneqqrho u_ku_ik+p_i-mu u_ikk","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"overbrace-rho(u_iju_iu_j)-(u_iip)+(pu_ii)+mu(u_iju_ij)^NS+overbracetau^mrho(u_ijRm_iu_j)+tau^m(p_iRm_i)+tau^c(u_iiRc)^SUPG =0qquad inquadOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(u_ipn_i)-mu(u_iu_ijn_j)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu^w_iu^w_jn_j)+(p(u^w_i-u_i)n_i)+mu(u_ij(u^w_i-u_i)n_j)+tau^brho(u_iu_i-u^w_i)=0qquad onquad(partialOmega)_inflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu_iu_jn_j)=0qquad onquad(partialOmega)_outflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(p-u_in_i)+mu(u_ij-u_in_j)+tau^brho(u_iu_i)=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"where u_iprhomu are the velocity, pressure, density and the dynamic viscosity respectively. The code is:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Δx = 0.02 # r = 0.1\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128\nτᵇ = μ / ρ * Cᵇ / Δx\nτᵖ = Cᵇ * Δx / μ\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n\n    NS_boundary_BASE = Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n    NS_boundary_INFLOW = ρ * Bilinear(u{i}, uʷ{i} * uʷ{j} * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +  μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_OUTFLOW = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + τᵖ * Bilinear(p, p)\n    NS_boundary_FIX = Bilinear(p, - u{i} * n{i}) + μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_inflow = NS_boundary_BASE + NS_boundary_INFLOW\n    WF_boundary_outflow = NS_boundary_BASE + NS_boundary_OUTFLOW\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, inflow_bg_ID, WF_boundary_inflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, outflow_bg_ID, WF_boundary_outflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Assemble","page":"Incompressible flow pass a cylinder","title":"Assemble","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"initialize_LocalAssembly!(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_order = 2, itg_order = 6, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Run","page":"Incompressible flow pass a cylinder","title":"Run","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables!(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = idrs!, Pl_func = Pl_Jacobi, maxiter = 2000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-6\n\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\n\n@Takeout (controlpoints, facets, elements) FROM fem_domain.workpieces[1].mesh\ncp_IDs = findall(controlpoints.is_occupied)\nys = controlpoints.x2[cp_IDs]\nzs = controlpoints.x3[cp_IDs]\nUm = 0.45\ncontrolpoints.uʷ1[cp_IDs] .= (16 * Um / H ^ 4) .* (ys .* zs .* (H .- ys) .* (H .- zs))\n\ntmax = 1\nfor i = 1:tmax\n    dt = fem_domain.globalfield.dt = 0.2 * Δx / Um\n\n    controlpoints.τᵐ[cp_IDs] .= (9 * 16 * ν ^ 2 * dim * Δx ^ (-4)) ^ (-0.5)\n    controlpoints.τᶜ[cp_IDs] .= (controlpoints.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n    update_OneStep!(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)\nend","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Save-to-VTK","page":"Incompressible flow pass a cylinder","title":"Save to VTK","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), wp)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/stress_concentration/stress_concentration.jl\"","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Stress-concentration-of-a-hole","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"In an elasticity class, we may learn that the stress concentration factor for a cylinderical hole is 3 while for a spherical hole is 2, as plotted: (Image: sc)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"In this example do the 3D case, while both 2D/3D source with mesh/data/visualization can be found here.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"using MetaFEM\ninitialize_Definitions!()\nfem_domain = FEM_Domain(dim = 3)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Geometry","page":"Stress concentration of a hole","title":"Geometry","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"The mesh is generated with Abaqus. Note, we have only the first order mesh loader and the higher order mesh is regenerated inside MetaFEM.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"element_shape = :CUBE\nsrc_fname = joinpath(@__DIR__, \"3D_Mesh.inp\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"To define the boundary (facets), there should be an more elegant interface later","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nL, err_scale = 5., 0.05\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L .+ err_scale)) .& (x2_mean .> (L .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L .+ err_scale)) .& (x3_mean .> (L .- err_scale))]\n\nwp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)\nd1_fix_bg_ID = add_Boundary!(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nd2_fix_bg_ID = add_Boundary!(wp_ID, facet_IDs_front; fem_domain = fem_domain) #left fixed\nd3_fix_bg_ID = add_Boundary!(wp_ID, facet_IDs_bottom; fem_domain = fem_domain) #left fixed\n\nfree_bg_ID = add_Boundary!(wp_ID, vcat(facet_IDs_right, facet_IDs_top); fem_domain = fem_domain) #bot & right free\nloaded_bg_ID = add_Boundary!(wp_ID, facet_IDs_back; fem_domain = fem_domain) #top loadeds","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Physics","page":"Stress concentration of a hole","title":"Physics","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"Only 1/8 domain is simulated to use symmetry.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"E = 210e9\nν = 0.3\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 10000 * E / L ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_d1_fixed_bdy = τᵇ * Bilinear(d{1}, (dʷ{1} - d{1}))\n    WF_d2_fixed_bdy = τᵇ * Bilinear(d{2}, (dʷ{2} - d{2}))\n    WF_d3_fixed_bdy = τᵇ * Bilinear(d{3}, (dʷ{3} - d{3}))\n    WF_loaded_bdy = Bilinear(d{2}, σˡ{2,2} * n{2})\nend\n\nassign_WorkPiece_WeakForm!(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, d1_fix_bg_ID, WF_d1_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, d2_fix_bg_ID, WF_d2_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, d3_fix_bg_ID, WF_d3_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, loaded_bg_ID, WF_loaded_bdy; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Assembly-and-Run","page":"Stress concentration of a hole","title":"Assembly & Run","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"Note, the code generated in \"compile_Updater_GPU\" is only used by \"update_OneStep\" so its position with the mesh update doesn't matter.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"initialize_LocalAssembly!(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables!(; fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\nfem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = idrs!, maxiter = 2000, max_pass = 20, s = 20)\nfem_domain.globalfield.converge_tol = 1e-8\nσ_external = 1\n\ncp = fem_domain.workpieces[1].mesh.controlpoints\ncp.σˡ2 .= σ_external\n\nupdate_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X!(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#VTK","page":"Stress concentration of a hole","title":"VTK","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"3D_MetaFEM.vtk\"), wp)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/pikachu/pikachu.jl\"","category":"page"},{"location":"examples/md/pikachu/pikachu/#Thermal-conduction-in-a-pikachu","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Let's begin with simulating the temperature distribution on a pikachu. Among all the examples, this example contains the most detailed discussion. The scripts with data/visualization can also be found in the example folder.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"First, we load the package by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"using MetaFEM\ninitialize_Definitions!()","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"The function initialize_Definitions clears the previous defined environment to prevent any interference if we run multiple scripts in sequence. Then we define a \"FEM_Domain\" of dimension 3, which will finally turn to one linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain = FEM_Domain(; dim = 3)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Geometry","page":"Thermal conduction in a pikachu","title":"Geometry","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Every FEM simulation needs a mesh. In MetaFEM we need to read mesh as (vert, connections). \"vert\" is a dim times N_n CuArray of coordinates, where N_n is the number of nodes, while \"connections\" is a N_v times N_e CuArray of sequenced node IDs where N_v is the number of nodes in each element and N_e is the total element number, very similar to the mesh loading process in other fields, e.g., for plotting. The input mesh is assumed to be at first order, i.e., every node is the end of some edges. Higher order elements will be regenerated inside MetaFEM based on the first order mesh.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Here we read the mesh from file 3D_COMSOL_Mesh.mphtxt generated by COMSOL and should be copied to the same folder as your script. The vertices coordinates are divided by 100 here because the source mesh of our pikachu has the length scale in cm. As for the function names, the mesh of the body is named a TotalMesh, in contrast to BoundaryMesh which only contains the boundary nodes/edges/faces","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"element_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we add a \"workpiece\", an object which will be assigned physics later, to our FEM_Domain, which returns wp_ID (the workpiece ID) for later reference by simply \"fem_domain.workpieces[wp_ID]\". Multiple workpieces in the same domain will be solved in coupling as a monolithic linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"wp_ID = add_WorkPiece!(ref_mesh; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to define boundary. We call \"get_BoundaryMesh\" to return all the IDs for the boundary faces (segments in 2D domain). We assign all of them as one boundary, assuming our pikachu is under convection in homogeneous air.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary!(wp_ID, fIDs; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Physics","page":"Thermal conduction in a pikachu","title":"Physics","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we are going to define physics, the most joyful part of the code. On the one hand, the mathematical formulation for the heat conduction in the pikachu Omega with convection on partialOmega is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"textvariablequad Tqquadtextparametersquad CkhT_envs","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"h(TT_env-T)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"where T is the body temperature, k is the thermal conductivity, h is the convective coefficient, T_env is the environment (air) temperature, s is the heat source.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"On the other hand, the code is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"k = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\n\n@Sym T\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm!(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm!(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Fairly self-illustrative, isn't it? Remarks:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"C, k, h, T_env are just Julia native variables, i.e., floating-point numbers (with SI base units);\ns is an external variable, which means they will not be differentiated and allocated in the final linear system Kx=d, but they will have a number per workpiece controlpoint (alias for the FEM mesh vertex, in contrast to the first order mesh nodes we used to describe the geometry).\nOnly the variables which are actually in use (in a weak-form assigned to a workpiece) will be allocated. Also, MetaFEM has the default variable declarations:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (x, CONTROLPOINT_VAR) (y, CONTROLPOINT_VAR) (z, CONTROLPOINT_VAR) (t, GLOBAL_VAR) (dt, GLOBAL_VAR)\n@External_Sym (n, INTEGRATION_POINT_VAR) (δ, SYMMETRIC_TENSOR) ϵ","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"By @Def, the expressions are parsed. The basic unit for FEM weak-form is a bilinear form, denoted by the function \"Bilinear\". The symbols or numbers in curly bracket define the subscripts. The semicolon \";\" in code is the comma \",\" in math separating the component index and the derivatives while the comma \",\" in code is just a separator betweewn symbols. The symbol \"t\" is reserved only for the derivative index to denote the time derivative. Note, a Julia variable like k is evaluated and fixed in @Def parsing, so if we want a changeable k, we should use:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (k, GLOBAL_VAR)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"The system understands free/dumb indices so the script should look just like something one may write on the blackboard in a mechanics class.\nWe do not have fixed high-level concepts like \"Dirichlet/Neumann/Robin/... boundary\", everything is just a weak-form, capable of full customization;\n\"assign_WorkPiece_WeakForm\" assigns heat_dissipation to the wp_ID workpiece of the domain fem_domain and \"assign_Boundary_WeakForm\" assigns conv_boundary to the flux_bg_ID boundary of the the wp_ID workpiece of the domain fem_domain.","category":"page"},{"location":"examples/md/pikachu/pikachu/#Assembly","page":"Thermal conduction in a pikachu","title":"Assembly","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"After defining physics, we need to collect, classify and number all the variables each workpiece. We may defines explicitly the maximum spatial differential order per workpiece, i.e., weak-form spatial derivatives order higher than \"explicit_max_sd_order\" will not be stored to save memory. Memory usage for interpolation points ~ (order + 1)^dim, e.g., discard second order spatial derivatives in 3D can bring a 27 to 8 memory usage reduction in the element memory usage.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"initialize_LocalAssembly!(fem_domain; explicit_max_sd_order = 1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we regenerate our mesh to second order serendipity elements with fifth Gaussian quadrature. Note, \"mesh_Classical\" needs to know variables so it must be after \"initialize_LocalAssembly\".","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Also we need to generate the simulation codes, where \"domain_ID\" is just used to generated function symbol.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Run-and-Output","page":"Thermal conduction in a pikachu","title":"Run & Output","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we are ready for simulation! First update geometry information such as the Jacobians/interpolation values/... by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we allocate the K x text and  d:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"assemble_Global_Variables!(fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to choose a linear solver. For a small-sized problem, CPU solver, defined here using LinearAlgebra.lu, is actually faster, although the data will still be passed to GPU anyway.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain.linear_solver = solver_LU_CPU","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"However, an iterative solver is the most usual choice because it scales better. Empirically, the most handy iterative solvers are the Induced Dimension Reduction \"IDR(s)\" and Stabilized Bi Conjugate Gradient \"BICGSTAB(l)\" where IDR(s) is faster and BICGSTAB(l) is more robust. We also provide some more, e.g., GMRES (prone to early stagnation when ill-conditioned), LSQR (which is the most robust one, even for a completely random matrix,  but often converges with the slowest speed), CGS/CGS2 (oscillate a lot before convergence but efficient for some problems, e.g., incompressible flow) and TFQMR (milder than CGS). In each example, there is at least one usable (both robust and efficient) iterative solver provided. In this specific case, we choose the IDRs solver. By default, the solver will be preconditioned with the right Jacobi preconditioner.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain.linear_solver = x -> iterative_Solve!(x; Sv_func! = idrs!, maxiter = 2000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-6","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Assign initial values and external variables:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"cpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn't need initial values, but just for completeness. The default initial values are zeros.\ncpts.s[cp_IDs] .= 1600.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Solve K(Delta x) = d and do x += Delta x:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"update_OneStep!(fem_domain.time_discretization; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Pull global x to local variables. (Pushing local to global is included in \"update_OneStep!\"):","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"dessemble_X!(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Save to vtk, note, scale is only for length:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"write_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), fem_domain.workpieces[1]; scale = 100)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika2)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MetaFEM.jl","page":"Home","title":"MetaFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to MetaFEM, a GPU-accelerated generic finite element solver. ","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Function-wise, MetaFEM is similar to a skeleton version of FEniCS or FreeFEM, i.e., MetaFEM takes in some high-level mathematical expressions (PDE weak-forms) and a mesh, e.g., thermal conduction in a pikachu, then outputs the corresponding simulation, e.g., to VTK files, resulting in something similar to the logo through common softwares like Paraview. Different from the classical approaches, however, MetaFEM uses only the most fundamental concepts, i.e., tensor components added, multiplied or algebraically operated in the variational form(s). There is no RHS/LHS, no Dirichlet boundary, no helper functions like grad/nabla, etc., but only the variational residue in the component form.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Software-wise, MetaFEM is an original implementation from nearly scratch, i.e., MetaFEM is natively coded in Julia directly based on CUDA.jl, with the adaptations from the other two external libraries: MacroTools.jl and IterativeSolvers.jl. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MetaFEM contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rule-based Computer Algebra System (CAS), i.e., symbolic differentiation and simplification;\nA 2D/3D mesh system, with simplex/cube Lagrangian elements at arbitrary order and cubic serendipity elements at either order 2 or 3;\nA FEM kernel which assembles everything, generates the code and solve it; and\nThe infrastructure to put the simulation on GPU.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A few examples are readily usable, starting with the pikachu case are here while the source files with all/most relevant data can be found here, which can be another good starting point (since the code is updated more frequently than the document).  In each subfolder of the source files, the *.jl file is the main script that actually works. Paraview state file(s) *.pvsm may be also helpful for quick visualization, by open Paraview-File-Load State.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nMetaFEM is under development. Any input, e.g., questions of usage, bugs, feature requests, or any ideas to make it better, will be very welcomed. Please feel free to open an issue on Github or directly email me at jiaxixie2022@u.northwestern.edu.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Through REPL-Pkg, i.e., Press ] in Julia REPL to enter pkg>, then:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MetaFEM","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or directly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MetaFEM\")","category":"page"}]
}
