var documenterSearchIndex = {"docs":
[{"location":"api/","page":"APIs","title":"APIs","text":"In MetaFEM V0.1.0 there are in total 30 exposed API functions/macros/types/gloabal variables.","category":"page"},{"location":"api/#Core","page":"APIs","title":"Core","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"MetaFEM has three basic data structures:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"FEM_Domain, the overall system, defines Kx=d.\nWorkPiece, a mesh assigned with physics, defines both domain physics and other numerical modifications like stabilization.\nBoundary, an array of segment/face IDs assigned with physics, defines boundary condition.","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    FEM_Domain\r\n    MetaFEM.WorkPiece\r\n    add_Boundary","category":"page"},{"location":"api/#MetaFEM.FEM_Domain","page":"APIs","title":"MetaFEM.FEM_Domain","text":"FEM_Domain\n\nA FEM_Domain contains everything needed to assemble a linear system Kx=d in FEM. The attributes are:\n\ndim, the dimension, 2 or 3.\nworkpieces, the array of all the WorkPieces in this domain, which will be finally solved in fully coupling.\ntools, reserved for the external geometry Tool, e.g., for contact. Not implemented.\ntime_discretization, the temporal discritization scheme. Currently only generalized-α method is implemented.\nglobalfield, the container for sparse K, dense x and d in Kx=d.\nK_linear_func the generated function to update the linear part of K.\nK_nonlinear_func the generated function to update the nonlinear part of K and the residue d.\nlinear_solver, the applied linear solver.\n\nTo add a FEM_Domain of dimension dim, the exposed API is:\n\nFEM_Domain(; dim::Integer)\n\nwhich returns the new FEM_Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaFEM.WorkPiece","page":"APIs","title":"MetaFEM.WorkPiece","text":"WorkPiece\n\nA WorkPiece is a meshed part assigned with some known physics. The attributes are:\n\nref_geometry, the first order mesh to describe the FEM_Geometry.\nphysics, the raw PDE weakforms.\nlocal_assembly, the re-organized PDE weakforms with sorted/indexed variables.\nmax_sd_order, an explicit limit of the maximum spatial derivative order to save memory.\nelement_space, the information about the spatial discritization, i.e., interpolation and intergration.\nmesh, the mesh regenerated according to the element_space and actually used in simulation.\n\nTo add a Workpiece with the geometry ref_geometry to the FEM_Domain fem_domain, the exposed API is:\n\nadd_WorkPiece(ref_geometry; fem_domain::FEM_Domain)\n\nwhich returns the WorkPiece ID in the fem_domain.workpieces.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaFEM.add_Boundary","page":"APIs","title":"MetaFEM.add_Boundary","text":"add_Boundary(ID::Integer, bdy_ref_edge_IDs::CuVector; fem_domain::FEM_Domain = fem_domain, target::Symbol = :WorkPiece)\n\nIn a 2D/3D FEM_Domain fem_domain, mark the segment/face IDs of the WorkPiece fem_domain.workpieces[wp_ID] as a boundary, to assign physics later. Multiple boundaries are independent from each other and can share the same segment/face IDs. If target = :Tool, the boundary is of fem_domain.tools[wp_ID], not implemented.\n\nThe function returns the boundary group ID bg_ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mesh","page":"APIs","title":"Mesh","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"The input to define a mesh is (vert, connections), very similar to the mesh loading process in other fields, e.g., for plotting","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"vert is a dim times N_n CuArray of coordinates, where N_n is the number of nodes.\nconnections is a N_v times N_e CuArray of sequenced node IDs where N_v is the number of nodes in each element and N_e is the total element number.","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"To define (vert, connections), we have the following helper functions:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    make_Square\r\n    read_Mesh","category":"page"},{"location":"api/#MetaFEM.make_Square","page":"APIs","title":"MetaFEM.make_Square","text":"make_Square(x::Tuple, n::Tuple, shape = :CUBE)\nmake_Brick(x::Tuple, n::Tuple, shape = :CUBE)\n\nHelper functions to creates a grid, i.e., the mesh nodes are positioned at cubic lattice points, with mesh shape = :CUBE or :SIMPLEX defining the connection.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.read_Mesh","page":"APIs","title":"MetaFEM.read_Mesh","text":"read_Mesh(filename::String)\n\nThe function loads an external mesh. Currently supported file types are:\n\n.inp file, Abaqus first order mesh.\n.mphtxt file, COMSOL mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"With (vert, connections), the first order mesh can be defined by:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    construct_TotalMesh","category":"page"},{"location":"api/#MetaFEM.construct_TotalMesh","page":"APIs","title":"MetaFEM.construct_TotalMesh","text":"construct_TotalMesh(coors::CuArray, connections::CuArray)\n\nThe function reads (vert, connections) and declares the first order mesh, FEM_Geometry.\n\nThere are 4 concepts in a FEM_Geometry:\n\nEach vertex in vertices stores the vertex coordinates.\nEach segment in segments stores the vertex IDs connected to this segment.\nEach face in faces stores both the vertex IDs and the segment IDs connected to this face.\nEach block in blocks stores the vertex IDs, the segment IDs and the face IDs connected to this block.\n\nIf applicable, the IDs are in order, e.g., segment IDs in a face are clockwise/counter-clockwise (since we can't define an outward normal for a bare face).\n\nThe function returns either a Geo_TotalMesh2D with attributes (vertices, segments, faces) or a  Geo_TotalMesh3D with attributes (vertices, segments, faces, blocks).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"We also have the helper function to define boundaries:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    get_BoundaryMesh","category":"page"},{"location":"api/#MetaFEM.get_BoundaryMesh","page":"APIs","title":"MetaFEM.get_BoundaryMesh","text":"get_BoundaryMesh(total_mesh::Geo_TotalMesh2D)\nget_BoundaryMesh(total_mesh::Geo_TotalMesh3D)\n\nHelper function to collect all the segment/face IDs which can be marked as boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#Symbolics","page":"APIs","title":"Symbolics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"The APIs to define the physics are pretty straightforward:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    @Sym\r\n    @Def\r\n    assign_Boundary_WeakForm\r\n    visualize","category":"page"},{"location":"api/#MetaFEM.@Sym","page":"APIs","title":"MetaFEM.@Sym","text":"@Sym (name, attribute_1, attribute_2,...)\n@External_Sym (name, attribute_1, attribute_2,...)\n\n@Sym declares a variable symbol name with the attributes attribute_1, attribute_2, ...,  which is simply stored as the pair name => (attribute_1, attribute_2, ...) in the exposed global dictionary VARIABLE_ATTRIBUTES.\n\n@External_Sym is just the @Sym with one default attribute: :EXTERNAL_VAR.\n\n\n\n\n\n","category":"macro"},{"location":"api/#MetaFEM.@Def","page":"APIs","title":"MetaFEM.@Def","text":"@Def ex \n@Def begin\n    ex1\n    ex2\n    ...\nend\n\n@Def defines a symbolic term, e.g., 1, σ{i, j}`, Bilinear(⋅, ⋅), etc.\n\n\n\n\n\n","category":"macro"},{"location":"api/#MetaFEM.assign_Boundary_WeakForm","page":"APIs","title":"MetaFEM.assign_Boundary_WeakForm","text":"assign_WorkPiece_WeakForm(wp_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)\nassign_Boundary_WeakForm(wp_ID::Integer, bg_ID::Integer, this_term::SymbolicTerm; fem_domain::FEM_Domain)\n\nThe functions assign this_term, which is either a bilinear term Bilinear(⋅, ⋅), or a sum of the bilinear terms, to the target WorkPiece or boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"The internal mechanism is different from the classical approaches and worth mentioning: The expressions will go through symbolic rewriting with rewriting rules, enabling customizations.","category":"page"},{"location":"api/#Assembly","page":"APIs","title":"Assembly","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"There are some necessary preprocesses:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    initialize_LocalAssembly\r\n    mesh_Classical\r\n    compile_Updater_GPU","category":"page"},{"location":"api/#MetaFEM.initialize_LocalAssembly","page":"APIs","title":"MetaFEM.initialize_LocalAssembly","text":"initialize_LocalAssembly(fem_domain::FEM_Domain; explicit_max_sd_order::Integer = 9)\ninitialize_LocalAssembly(dim::Integer, workpieces::Vector{WorkPiece}; explicit_max_sd_order::Integer = 9)\n\nThis function preprocesses/reorganizes the weakforms. The input explicit_max_sd_order is the exposed API for  explicitly limit high order spatial derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.mesh_Classical","page":"APIs","title":"MetaFEM.mesh_Classical","text":"mesh_Classical(wp_IDs; shape::Symbol, itp_type::Symbol = :Lagrange, itp_order::Integer, itg_order::Integer, fem_domain::FEM_Domain)\n\nThe function generates the mesh of order itp_order, interpolation type itp_type = :Lagrange/:Serendipity with gaussian quadrature of order itg_order on fem_domain.workpieces[wp_IDs]. The dimension and mesh type (:CUBE/:SIMPLEX) will follow the first order mesh of each WorkPiece.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.compile_Updater_GPU","page":"APIs","title":"MetaFEM.compile_Updater_GPU","text":"compile_Updater_GPU(; domain_ID::Integer, fem_domain::FEM_Domain)\n\nThe function generates fem_domain.K_linear_func and fem_domain.K_nonlinear_func. The input domain_ID is only used to generate the function name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-simulation","page":"APIs","title":"Update simulation","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"    update_Mesh\r\n    assemble_Global_Variables\r\n    update_OneStep\r\n    dessemble_X","category":"page"},{"location":"api/#MetaFEM.update_Mesh","page":"APIs","title":"MetaFEM.update_Mesh","text":"update_Mesh(dim::Integer, wp::WorkPiece, this_space::Classical_Discretization)\n\nThis function updates Jacobians and interpolation values.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.assemble_Global_Variables","page":"APIs","title":"MetaFEM.assemble_Global_Variables","text":"assemble_Global_Variables(; fem_domain::FEM_Domain)\n\nThis function allocates the sparse K, dense x and d.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.update_OneStep","page":"APIs","title":"MetaFEM.update_OneStep","text":"update_OneStep(time_discretization::GeneralAlpha; max_iter::Integer = 4, fem_domain::FEM_Domain)\n\nThis function calculates K(Δx)=d and updates x += (Δx). max_iter determines the maximum iteration for Δx with different K and d in nonlinear cases. The converge tolerance is determined by fem_domain.globalfield.converge_tol while the linear solver is fem_domain.linear_solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.dessemble_X","page":"APIs","title":"MetaFEM.dessemble_X","text":"dessemble_X(workpieces::Vector{WorkPiece}, globalfield::GlobalField)\n\nThis function dessembles globalfield.x to local data, i.e., workpiece.mesh.controlpoint.sym, like workpiece.mesh.controlpoint.T.\n\n\n\n\n\n","category":"function"},{"location":"api/#Linear-solvers","page":"APIs","title":"Linear solvers","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"In update_OneStep, the linear solver, fem_domain.linear_solver is called, which is supposed to take a globalfield and return the dx. We provide the following linear solvers:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    solver_LU_CPU\r\n    solver_QR\r\n    solver_LU\r\n    solver_BiCG\r\n    solver_IDRs","category":"page"},{"location":"api/#MetaFEM.solver_LU_CPU","page":"APIs","title":"MetaFEM.solver_LU_CPU","text":"solver_LU_CPU(globalfield)\n\nCPU LU solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_QR","page":"APIs","title":"MetaFEM.solver_QR","text":"solver_QR(globalfield; reorder::Integer = 1, singular_tol::Number)\n\nGPU QR solver with CUDA's csrlsvqr!.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_LU","page":"APIs","title":"MetaFEM.solver_LU","text":"solver_LU_CPU(globalfield; reorder::Integer = 1, singular_tol::Number)\n\nGPU LU solver with CUDA's csrlsvlu!. Note, csrlsvlu! is essentially a host function and the device part is not accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_BiCG","page":"APIs","title":"MetaFEM.solver_BiCG","text":"solver_BiCG(globalfield; Pl_func::Function = precondition_Nothing, max_iter = 5000, max_pass = 4, l = 8)\n\nGPU bicgstabl (a classical stablized bi conjugate gradient method) solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.solver_IDRs","page":"APIs","title":"MetaFEM.solver_IDRs","text":"solver_IDRs(globalfield; Pl_func::Function = precondition_Nothing, max_iter = 5000, max_pass = 4, s = 8)\n\nGPU IDRs (induced dimension reduction) solver.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"APIs","title":"APIs","text":"with the following preconditioners:","category":"page"},{"location":"api/","page":"APIs","title":"APIs","text":"    precondition_CUDA_Jacobi\r\n    precondition_CUDA_ILU","category":"page"},{"location":"api/#MetaFEM.precondition_CUDA_Jacobi","page":"APIs","title":"MetaFEM.precondition_CUDA_Jacobi","text":"precondition_CUDA_Jacobi(A::CuSparseMatrixCSR{T})\n\nGPU Jacobi preconditioner.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.precondition_CUDA_ILU","page":"APIs","title":"MetaFEM.precondition_CUDA_ILU","text":"precondition_CUDA_ILU(A)\n\nGPU ILU preconditioner with CUDA's ilu02!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-helper-functions","page":"APIs","title":"Other helper functions","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"    write_VTK\r\n    @Takeout","category":"page"},{"location":"api/#MetaFEM.write_VTK","page":"APIs","title":"MetaFEM.write_VTK","text":"write_VTK(fname::String, wp::WorkPiece; scale = 1.)\n\nOutput all the variables in WorkPiece wp to file fname. The scale is only for the length scale, i.e., node coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaFEM.@Takeout","page":"APIs","title":"MetaFEM.@Takeout","text":"@Takeout a, b FROM c\n\nequals \n\na = c.a\nb = c.b\n\nwhile\n\n@Takeout a, b FROM c WITH PREFIX d\n\nequals \n\nda = c.a\ndb = c.b\n\n\n\n\n\n","category":"macro"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cylinderflow/cylinderflow.jl\"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Incompressible-flow-pass-a-cylinder","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"In this example we simulate a flow case like this (Image: flow) First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"using MetaFEM\ndim = 3\nfem_domain = FEM_Domain(; dim = dim)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Geometry","page":"Incompressible flow pass a cylinder","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Load the mesh \"3D_COMSOL_Mesh.mphtxt\" which can be found in here and should be put under the same directory of the script.","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"L = 2.5\nH = 0.41\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Define boundary:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = 0.01\n\nis_left = (x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))\nis_right = (x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, facet_IDs[.~(is_left .| is_right)]; fem_domain = fem_domain)\ninflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_left]; fem_domain = fem_domain)\noutflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_right]; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Physics","page":"Incompressible flow pass a cylinder","title":"Physics","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"The steady state Navier-Stokes (NS) equation with Streamline-Upwind/Peterove-Galerkin (SUPG) stabilization can be formed as follows:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"textvariablequad u_ipqquadtextparametersquadrhomuu^W_itau^btau^ctau^m","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Rccoloneqq u_kkqquad Rm_icoloneqqrho u_ku_ik+p_i-mu u_ikk","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"overbrace-rho(u_iju_iu_j)-(u_iip)+(pu_ii)+mu(u_iju_ij)^NS+overbracetau^mrho(u_ijRm_iu_j)+tau^m(p_iRm_i)+tau^c(u_iiRc)^SUPG =0qquad inquadOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(u_ipn_i)-mu(u_iu_ijn_j)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu^w_iu^w_jn_j)+(p(u^w_i-u_i)n_i)+mu(u_ij(u^w_i-u_i)n_j)+tau^brho(u_iu_i-u^w_i)=0qquad onquad(partialOmega)_inflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu_iu_jn_j)=0qquad onquad(partialOmega)_outflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(p-u_in_i)+mu(u_ij-u_in_j)+tau^brho(u_iu_i)=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"where u_iprhomu are the velocity, pressure, density and the dynamic viscosity respectively. The code is:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Δx = 0.02 # r = 0.1\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128\nτᵇ = μ / ρ * Cᵇ / Δx\nτᵖ = Cᵇ * Δx / μ\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n\n    NS_boundary_BASE = Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n    NS_boundary_INFLOW = ρ * Bilinear(u{i}, uʷ{i} * uʷ{j} * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +  μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_OUTFLOW = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + τᵖ * Bilinear(p, p)\n    NS_boundary_FIX = Bilinear(p, - u{i} * n{i}) + μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_inflow = NS_boundary_BASE + NS_boundary_INFLOW\n    WF_boundary_outflow = NS_boundary_BASE + NS_boundary_OUTFLOW\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, inflow_bg_ID, WF_boundary_inflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, outflow_bg_ID, WF_boundary_outflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Assemble","page":"Incompressible flow pass a cylinder","title":"Assemble","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"initialize_LocalAssembly(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_order = 2, itg_order = 6, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Run","page":"Incompressible flow pass a cylinder","title":"Run","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_Jacobi, max_iter = 5000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-5\n\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n@Takeout (controlpoints, facets, elements) FROM fem_domain.workpieces[1].mesh\ncp_IDs = findall(controlpoints.is_occupied)\nys = controlpoints.x2[cp_IDs]\nzs = controlpoints.x3[cp_IDs]\nUm = 0.45\ncontrolpoints.uʷ1[cp_IDs] .= (16 * Um / H ^ 4) .* (ys .* zs .* (H .- ys) .* (H .- zs))\n\ntmax = 1\nfor i = 1:tmax\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / Um\n\n    controlpoints.τᵐ[cp_IDs] .= (9 * 16 * ν ^ 2 * dim * Δx ^ (-4)) ^ (-0.5)\n    controlpoints.τᶜ[cp_IDs] .= (controlpoints.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Save-to-VTK","page":"Incompressible flow pass a cylinder","title":"Save to VTK","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), wp)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Bare-script","page":"Incompressible flow pass a cylinder","title":"Bare script","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"using MetaFEM\ndim = 3\nfem_domain = FEM_Domain(; dim = dim)\n\nL = 2.5\nH = 0.41\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = 0.01\n\nis_left = (x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))\nis_right = (x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, facet_IDs[.~(is_left .| is_right)]; fem_domain = fem_domain)\ninflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_left]; fem_domain = fem_domain)\noutflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_right]; fem_domain = fem_domain)\n\nΔx = 0.02 # r = 0.1\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128\nτᵇ = μ / ρ * Cᵇ / Δx\nτᵖ = Cᵇ * Δx / μ\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n\n    NS_boundary_BASE = Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n    NS_boundary_INFLOW = ρ * Bilinear(u{i}, uʷ{i} * uʷ{j} * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +  μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_OUTFLOW = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + τᵖ * Bilinear(p, p)\n    NS_boundary_FIX = Bilinear(p, - u{i} * n{i}) + μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_inflow = NS_boundary_BASE + NS_boundary_INFLOW\n    WF_boundary_outflow = NS_boundary_BASE + NS_boundary_OUTFLOW\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, inflow_bg_ID, WF_boundary_inflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, outflow_bg_ID, WF_boundary_outflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_order = 2, itg_order = 6, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_Jacobi, max_iter = 5000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-5\n\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n@Takeout (controlpoints, facets, elements) FROM fem_domain.workpieces[1].mesh\ncp_IDs = findall(controlpoints.is_occupied)\nys = controlpoints.x2[cp_IDs]\nzs = controlpoints.x3[cp_IDs]\nUm = 0.45\ncontrolpoints.uʷ1[cp_IDs] .= (16 * Um / H ^ 4) .* (ys .* zs .* (H .- ys) .* (H .- zs))\n\ntmax = 1\nfor i = 1:tmax\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / Um\n\n    controlpoints.τᵐ[cp_IDs] .= (9 * 16 * ν ^ 2 * dim * Δx ^ (-4)) ^ (-0.5)\n    controlpoints.τᶜ[cp_IDs] .= (controlpoints.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), wp)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cantilever/cantilever.jl\"","category":"page"},{"location":"examples/md/cantilever/cantilever/#Linear-elastic-cantilever-bending","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"In this example we simulate a cantilever beam under different loads, as a straightforward check on the elasticity formulation by comparison to the analytical solutions. The source with data/visualization can also be found here.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Geometry","page":"Linear elastic cantilever bending","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"For cuboid geometry we have helper functions \"make_Square\"/\"make_Brick\" for 2D/3D:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"L_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Brick(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Defining boundary can be a little lengthy because we need to find those IDs. Any idea for improvement will be very welcomed.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top); fem_domain = fem_domain) #bottom & right & front free\nback_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #back will be loaded\nright_bg_ID = add_Boundary(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded","category":"page"},{"location":"examples/md/cantilever/cantilever/#Physics","page":"Linear elastic cantilever bending","title":"Physics","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The mathematical formulation is:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"textvariablequad d_iqquadtextparametersquad Enud^w_isigma^l_ijtau","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"lambda=fracEnu(1+nu)(1-2nu)qquadmu=fracE2(1+nu)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"epsilon_ij=fracd_ij+d_ji2qquadsigma_ij=lambdadelta_ijepsilon_mm+2muepsilon_ij","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"-(d_ijsigma_ij)=0qquad inquadOmega","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_isigma^l_ijn_j)=0qquad onquad(partialOmega)_load","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_itau(d^w_i-d_i))=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"where d_iEnulambdamuepsilon_ijsigma_ij are the displacement, Young’s modulus, Poisson ratio, Lame's first parameter, shear modulus, strain and stress, respectively.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The code is: (Note, if we set the Poisson ratio ν = 0.0, the spherical part, i.e., λ related terms, will be actaully removed by the simplification.)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Δx = L_box / e_number\nE = 1\nν = 0.001\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (σ², CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n\n    WF_right_bdy = Bilinear(d{i}, σˡ{i,j} * n{j})\n    WF_back_bdy = Bilinear(d{i}, σ²{i,j} * n{j})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, back_bg_ID, WF_back_bdy; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Assembly","page":"Linear elastic cantilever bending","title":"Assembly","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"initialize_LocalAssembly(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Run","page":"Linear elastic cantilever bending","title":"Run","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"we run for three different loading conditions:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ndx = L_box/e_number\nh, l = L_box, (L_box * LW_ratio)\nI = 1/12 * h ^ 3\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nhorizontal_mid_cp_IDs = findall((cpts.x2 .> L_box / 2 - err_scale * dx) .& (cpts.x2 .< L_box / 2 + err_scale * dx) .&\n                                (cpts.x3 .> L_box / 2 - err_scale * dx) .& (cpts.x3 .< L_box / 2 + err_scale * dx))\n\nx_plot = cpts.x1[horizontal_mid_cp_IDs] |> collect\nsorted_ids = sortperm(x_plot)\n\nhorizontal_mid_cp_IDs = horizontal_mid_cp_IDs[MetaFEM.cu(sorted_ids)]\nx_plot = x_plot[sorted_ids]\ny_plots = [[] for i = 1:2]\nplot_labels = [String[] for i = 1:2]\n\nσ_external = 1e6\ncpts.σˡ6 .= σ_external\ncpts.σ²2 .= 0\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external * L_box/(6 * E * I) * (3 * l .-  x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Concentrated load, analytical\")\npush!(plot_labels[2], \"Concentrated load, MetaFEM\")\n\ncpts.σˡ6 .= 0\ncpts.σ²2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (24 * E * I) * (x_plot.^2 .+ 6 * l ^ 2 .- 4 * l .* x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Uniform pressure, analytical\")\npush!(plot_labels[2], \"Uniform pressure, MetaFEM\")\n\ncpts.σ²2 .= σ_external .* (1. .- cpts.x1 ./ (L_box * LW_ratio))\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (120 * l * E * I) * (10 * l ^ 3 .- 10 * l^2 .* x_plot .+ 5 * l * x_plot .^ 2 .- x_plot .^ 3) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Linearly distributed pressure, analytical\")\npush!(plot_labels[2], \"Linearly distributed pressure, MetaFEM\")","category":"page"},{"location":"examples/md/cantilever/cantilever/#Plot","page":"Linear elastic cantilever bending","title":"Plot","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"With Plots.jl:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using Plots\nfig = plot(; size=(800,800), title = \"Normalized deflection on the line y = z = 0.5\", xlims = (-1., 11.), xticks = 0:2:10, ylims = (-0.1, 1.1), yticks = 0:0.2:1, xlabel = \"x\", ylabel = \"Normalized d₂\")\nfor i = 1:3\n    color_val = (i / 3 + 1) / 2\n    scatter!(fig, x_plot, y_plots[1][i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = plot_labels[1][i])\n    plot!(fig, x_plot, y_plots[2][i], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = plot_labels[2][i])\nend\nfig.subplots[1].attr[:legend_position] = (0.2, 0.8)\npng(fig, joinpath(@__DIR__, \"3D_Cantilever_Plots.png\"))","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(Image: cantilever)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Bare-script","page":"Linear elastic cantilever bending","title":"Bare script","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)\n\nL_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Brick(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top); fem_domain = fem_domain) #bottom & right & front free\nback_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #back will be loaded\nright_bg_ID = add_Boundary(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded\n\nΔx = L_box / e_number\nE = 1\nν = 0.001\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (σ², CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n\n    WF_right_bdy = Bilinear(d{i}, σˡ{i,j} * n{j})\n    WF_back_bdy = Bilinear(d{i}, σ²{i,j} * n{j})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, back_bg_ID, WF_back_bdy; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ndx = L_box/e_number\nh, l = L_box, (L_box * LW_ratio)\nI = 1/12 * h ^ 3\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nhorizontal_mid_cp_IDs = findall((cpts.x2 .> L_box / 2 - err_scale * dx) .& (cpts.x2 .< L_box / 2 + err_scale * dx) .&\n                                (cpts.x3 .> L_box / 2 - err_scale * dx) .& (cpts.x3 .< L_box / 2 + err_scale * dx))\n\nx_plot = cpts.x1[horizontal_mid_cp_IDs] |> collect\nsorted_ids = sortperm(x_plot)\n\nhorizontal_mid_cp_IDs = horizontal_mid_cp_IDs[MetaFEM.cu(sorted_ids)]\nx_plot = x_plot[sorted_ids]\ny_plots = [[] for i = 1:2]\nplot_labels = [String[] for i = 1:2]\n\nσ_external = 1e6\ncpts.σˡ6 .= σ_external\ncpts.σ²2 .= 0\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external * L_box/(6 * E * I) * (3 * l .-  x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Concentrated load, analytical\")\npush!(plot_labels[2], \"Concentrated load, MetaFEM\")\n\ncpts.σˡ6 .= 0\ncpts.σ²2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (24 * E * I) * (x_plot.^2 .+ 6 * l ^ 2 .- 4 * l .* x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Uniform pressure, analytical\")\npush!(plot_labels[2], \"Uniform pressure, MetaFEM\")\n\ncpts.σ²2 .= σ_external .* (1. .- cpts.x1 ./ (L_box * LW_ratio))\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (120 * l * E * I) * (10 * l ^ 3 .- 10 * l^2 .* x_plot .+ 5 * l * x_plot .^ 2 .- x_plot .^ 3) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Linearly distributed pressure, analytical\")\npush!(plot_labels[2], \"Linearly distributed pressure, MetaFEM\")\n\nusing Plots\nfig = plot(; size=(800,800), title = \"Normalized deflection on the line y = z = 0.5\", xlims = (-1., 11.), xticks = 0:2:10, ylims = (-0.1, 1.1), yticks = 0:0.2:1, xlabel = \"x\", ylabel = \"Normalized d₂\")\nfor i = 1:3\n    color_val = (i / 3 + 1) / 2\n    scatter!(fig, x_plot, y_plots[1][i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = plot_labels[1][i])\n    plot!(fig, x_plot, y_plots[2][i], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = plot_labels[2][i])\nend\nfig.subplots[1].attr[:legend_position] = (0.2, 0.8)\npng(fig, joinpath(@__DIR__, \"3D_Cantilever_Plots.png\"))\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/pikachu/pikachu.jl\"","category":"page"},{"location":"examples/md/pikachu/pikachu/#Thermal-conduction-in-a-pikachu","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Let's begin with simulating the temperature distribution on a pikachu. Among all the examples, this example contains the most detailed discussion. The source with data/visualization can also be found here.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"First, we load the package by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"using MetaFEM","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we define a \"FEM_Domain\" of dimension 3, which will finally turn to one linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain = FEM_Domain(; dim = 3)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Geometry","page":"Thermal conduction in a pikachu","title":"Geometry","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Every FEM simulation needs a mesh. In MetaFEM we need to read mesh as (vert, connections). \"vert\" is a dim times N_n CuArray of coordinates, where N_n is the number of nodes, while \"connections\" is a N_v times N_e CuArray of sequenced node IDs where N_v is the number of nodes in each element and N_e is the total element number, very similar to the mesh loading process in other fields, e.g., for plotting. The input mesh is assumed to be at first order, i.e., every node is the end of some edges. Higher order elements will be regenerated inside MetaFEM based on the first order mesh.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Here we read the mesh from file 3D_COMSOL_Mesh.mphtxt generated by COMSOL, which can be found here and should be copied to the same folder as your script. The vertices coordinates are divided by 100 here because the source mesh of our pikachu has the length scale in cm. As for the function names, the mesh of the body is named a TotalMesh, in contrast to BoundaryMesh which only contains the boundary nodes/edges/faces","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"element_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we add a \"workpiece\", an object which will be assigned physics later, to our FEM_Domain, which returns wp_ID (the workpiece ID) for later reference by simply \"fem_domain.workpieces[wp_ID]\". Multiple workpieces in the same domain will be solved in coupling as a monolithic linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"wp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to define boundary. We call \"get_BoundaryMesh\" to return all the IDs for the boundary faces (segments in 2D domain). We assign all of them as one boundary, assuming our pikachu is under convection in homogeneous air.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Physics","page":"Thermal conduction in a pikachu","title":"Physics","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we are going to define physics, the most joyful part of the code. On the one hand, the mathematical formulation for the heat conduction in the pikachu Omega with convection on partialOmega is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"textvariablequad Tqquadtextparametersquad CkhT_envs","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"h(TT_env-T)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"where T is the body temperature, C is the volumetric heat capacity, k is the thermal conductivity, h is the convective coefficient, T_env is the environment (air) temperature, s is the heat source.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"On the other hand, the code is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"C = 1.\nk = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Fairly self-illustrative, isn't it? Remarks:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"C, k, h, T_env are just Julia native variables, i.e., floating-point numbers (with SI base units);\ns is an external variable, which means they will not be differentiated and allocated in the final linear system Kx=d, but they will have a number per workpiece controlpoint (alias for the FEM mesh vertex, in contrast to the first order mesh nodes we used to describe the geometry).\nOnly the variables which are actually in use (in a weak-form assigned to a workpiece) will be allocated. Also, we did not define T because MetaFEM has default variable declaration of the following code:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (x, CONTROLPOINT_VAR) (y, CONTROLPOINT_VAR) (z, CONTROLPOINT_VAR) (t, GLOBAL_VAR) (dt, GLOBAL_VAR)\n@External_Sym (F, INTEGRATION_POINT_VAR) (f, INTEGRATION_POINT_VAR) (n, INTEGRATION_POINT_VAR) δ\n@Sym u p T","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"By @Def, the expressions are parsed. The basic unit for FEM weak-form is a bilinear form, denoted by the function \"Bilinear\". The symbols or numbers in curly bracket define the subscripts. The semicolon \";\" in code is the comma \",\" in math separating the component index and the derivatives while the comma \",\" in code is just a separator betweewn symbols. The symbol \"t\" is reserved only for the derivative index to denote the time derivative. Note, a Julia variable like k is evaluated and fixed in @Def parsing, so if we want a changeable k, we should use:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (k, GLOBAL_VAR)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"The system understands free/dumb indices so the script should look just like something one may write on the blackboard in a mechanics class.\nWe do not have fixed high-level concepts like \"Dirichlet/Neumann/Robin/... boundary\", everything is just a weak-form, capable of full customization;\n\"assign_WorkPiece_WeakForm\" assigns heat_dissipation to the wp_ID workpiece of the domain fem_domain and \"assign_Boundary_WeakForm\" assigns conv_boundary to the flux_bg_ID boundary of the the wp_ID workpiece of the domain fem_domain.","category":"page"},{"location":"examples/md/pikachu/pikachu/#Assembly","page":"Thermal conduction in a pikachu","title":"Assembly","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"After defining physics, we need to collect, classify and number all the variables each workpiece. Although there is a shorter version:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"initialize_LocalAssembly(fem_domain::FEM_Domain; explicit_max_sd_order::Integer) = initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"we still prefer to the following way which defines explicitly the maximum spatial differential order per workpiece, i.e., weak-form spatial derivatives order higher than \"explicit_max_sd_order\" will not be stored to save memory. Memory usage for interpolation points ~ (order + 1)^dim, e.g., 2-order to 1-order in 3D has a 27 to 8 memory usage difference.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we regenerate our mesh to second order serendipity elements with fifth Gaussian quadrature. Note, \"mesh_Classical\" needs to know variables so it must be after \"initialize_LocalAssembly\".","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Also we need to generate the simulation codes, where \"domain_ID\" is just used to generated function symbol.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Run-and-Output","page":"Thermal conduction in a pikachu","title":"Run & Output","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we are ready for simulation! First update geometry information such as the Jacobians/interpolation values/... by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we allocate the K x text and  d:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"assemble_Global_Variables(fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to choose a linear solver. For a small-sized problem, CPU solver, defined here using LinearAlgebra.lu, is actually faster, although the data will still be passed to GPU anyway.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Assign initial values and external variables:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"cpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn't need initial values, but just for completeness. The default initial values are zeros.\ncpts.s[cp_IDs] .= 1600.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Solve K(Delta x) = d and do x += Delta x:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"update_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Pull global x to local variables. (Pushing local to global is included in \"update_OneStep\"):","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"dessemble_X(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Save to vtk, note, scale is only for length:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"write_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), fem_domain.workpieces[1]; scale = 100)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika2)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Bare-script","page":"Thermal conduction in a pikachu","title":"Bare script","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"using MetaFEM\n\nfem_domain = FEM_Domain(; dim = 3)\n\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\n\nfIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)\n\nC = 1.\nk = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\n\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\n\nassemble_Global_Variables(fem_domain = fem_domain)\n\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn't need initial values, but just for completeness. The default initial values are zeros.\ncpts.s[cp_IDs] .= 1600.\n\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\n\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), fem_domain.workpieces[1]; scale = 100)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/thermal_stripe/thermal_stripe.jl\"","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Various-thermal-boundary-conditions-on-a-2D-stripe","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"(Image: stripe1)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"This case is another thermal example, which is also a tutorial in FEATool. # The MetaFEM source with data/visualization can also be found here.","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Load the package and define the domain:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"using MetaFEM\ndim = 2\nfem_domain = FEM_Domain(dim = dim)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Geometry","page":"Various thermal boundary conditions on a 2D stripe","title":"Geometry","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"For cuboid geometry we have helper functions \"make_Square\"/\"make_Brick\" for 2D/3D:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"L1, L2 = domain_size = (0.02, 0.01)\nΔx = 5e-4\nelement_number = Int.(domain_size ./ Δx) # 40 x 20 mesh\nelement_shape = :CUBE\n\nvertices, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"To define the boundaries, we need to find those sIDs (segment IDs):","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = Δx * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L1 .+ err_scale)) .& (x1_mean .> (L1 .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L2 .+ err_scale)) .& (x2_mean .> (L2 .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, vcat(sIDs_left, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary(wp_ID, sIDs_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Physics","page":"Various thermal boundary conditions on a 2D stripe","title":"Physics","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Similar to the pikachu case, but with volumetric heat dissipation, radiation boundary and fixed boundary, the mathematical formulation is:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"textvariablequad Tqquadtextparametersquad Ckhh_penaltyse_mT_envT_fix","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"-C(TT_t)-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"h(TT_env-T)+e_msigma^b(T T_env^4 - T^4)=0qquad onquadpartial(Omega)_convection_radiation","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"h_penalty(TT_fix-T) + k(Tn_iT_i)=0qquad onquadpartial(Omega)_fix","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"Note, for the fixed boundary we use Nitsche's formulation, i.e., with the gradient correction term:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":" k(Tn_iT_i)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"we can reduce the magnitude of h_penalty to a much smaller value than the bare penalty case. The code is:","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"T₀ = 273.15\nk = 3\nh = 50\nC = 1.\nα = 0.\nTw = 900. + T₀\nh_penalty = 1000.\nTₑₙᵥ = 50. + T₀\nem = 0.7\nσᵇ = 5.669e-8\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s + α * (Tₑₙᵥ - T))\n    conv_rad_boundary = h * Bilinear(T, Tₑₙᵥ - T) + em * σᵇ * Bilinear(T, Tₑₙᵥ^4 - T^4)\n    fix_boundary = h_penalty * Bilinear(T, Tw - T) + k * Bilinear(T, n{i} * T{;i})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, fix_boundary; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, top_bg_ID, conv_rad_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Assembly","page":"Various thermal boundary conditions on a 2D stripe","title":"Assembly","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Run","page":"Various thermal boundary conditions on a 2D stripe","title":"Run","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-4\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ\ncpts.s[cp_IDs] .= 0.\n\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Plot","page":"Various thermal boundary conditions on a 2D stripe","title":"Plot","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"With Plots.jl","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"using Plots\n\nmid_cp_IDs = (cpts.x1 .> L1/2 - 0.1 * Δx) .& (cpts.x1 .< L1/2 + 0.1 * Δx)\nnum_ys = cpts.x2[mid_cp_IDs] |> collect\nnum_Ts = cpts.T[mid_cp_IDs] |> collect\nids = sortperm(num_ys)\n\ny_sample = [0.0001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.0099] # Sampled from FEATool result\nT_sample = [1086.84,  1086,  1082.73,  1077.63,  1070.24,  1060.78,  1048.83,  1034.63,  1017.81,  998.843,  979.249]\n\nusing Plots\nfig = plot(; size=(800,800), title = \"Temperature along the middle line x = 1 cm\", xticks = 0.:0.002:0.01, xlabel = \"y(m)\", ylabel = \"T(K)\" )\nscatter!(fig, y_sample, T_sample, markershape = :rect, markersize = 6, color = RGBA(1, 0, 0, 1), label = \"FEATool\")\nplot!(fig, num_ys[ids], num_Ts[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, 0.5, 1), markercolor = RGBA(0, 0.5, 0.5, 1), label = \"MetaFEM\")\nfig.subplots[1].attr[:legend_position] = (0.8, 0.9)\npng(fig, joinpath(@__DIR__, \"2D_Thermal_Middle_Line_Plots.png\"))","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"(Image: stripe2) VTK","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"\\\\\", \"2D_Ceramic_Strip.vtk\"), wp)","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/#Bare-script","page":"Various thermal boundary conditions on a 2D stripe","title":"Bare script","text":"","category":"section"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"using MetaFEM\ndim = 2\nfem_domain = FEM_Domain(dim = dim)\n\nL1, L2 = domain_size = (0.02, 0.01)\nΔx = 5e-4\nelement_number = Int.(domain_size ./ Δx) # 40 x 20 mesh\nelement_shape = :CUBE\n\nvertices, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)\n\n@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = Δx * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L1 .+ err_scale)) .& (x1_mean .> (L1 .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L2 .+ err_scale)) .& (x2_mean .> (L2 .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, vcat(sIDs_left, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary(wp_ID, sIDs_top; fem_domain = fem_domain)\n\nT₀ = 273.15\nk = 3\nh = 50\nC = 1.\nα = 0.\nTw = 900. + T₀\nh_penalty = 1000.\nTₑₙᵥ = 50. + T₀\nem = 0.7\nσᵇ = 5.669e-8\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s + α * (Tₑₙᵥ - T))\n    conv_rad_boundary = h * Bilinear(T, Tₑₙᵥ - T) + em * σᵇ * Bilinear(T, Tₑₙᵥ^4 - T^4)\n    fix_boundary = h_penalty * Bilinear(T, Tw - T) + k * Bilinear(T, n{i} * T{;i})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, fix_boundary; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, top_bg_ID, conv_rad_boundary; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-4\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ\ncpts.s[cp_IDs] .= 0.\n\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\nusing Plots\n\nmid_cp_IDs = (cpts.x1 .> L1/2 - 0.1 * Δx) .& (cpts.x1 .< L1/2 + 0.1 * Δx)\nnum_ys = cpts.x2[mid_cp_IDs] |> collect\nnum_Ts = cpts.T[mid_cp_IDs] |> collect\nids = sortperm(num_ys)\n\ny_sample = [0.0001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.0099] # Sampled from FEATool result\nT_sample = [1086.84,  1086,  1082.73,  1077.63,  1070.24,  1060.78,  1048.83,  1034.63,  1017.81,  998.843,  979.249]\n\nusing Plots\nfig = plot(; size=(800,800), title = \"Temperature along the middle line x = 1 cm\", xticks = 0.:0.002:0.01, xlabel = \"y(m)\", ylabel = \"T(K)\" )\nscatter!(fig, y_sample, T_sample, markershape = :rect, markersize = 6, color = RGBA(1, 0, 0, 1), label = \"FEATool\")\nplot!(fig, num_ys[ids], num_Ts[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, 0.5, 1), markercolor = RGBA(0, 0.5, 0.5, 1), label = \"MetaFEM\")\nfig.subplots[1].attr[:legend_position] = (0.8, 0.9)\npng(fig, joinpath(@__DIR__, \"2D_Thermal_Middle_Line_Plots.png\"))\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"\\\\\", \"2D_Ceramic_Strip.vtk\"), wp)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"","category":"page"},{"location":"examples/md/thermal_stripe/thermal_stripe/","page":"Various thermal boundary conditions on a 2D stripe","title":"Various thermal boundary conditions on a 2D stripe","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/stress_concentration/stress_concentration.jl\"","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Stress-concentration-of-a-hole","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"In an elasticity class, we may learn that the stress concentration factor for a cylinderical hole is 3 while for a spherical hole is 2, as plotted: (Image: sc)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"In this example do the 3D case, while both 2D/3D source with mesh/data/visualization can be found here.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Geometry","page":"Stress concentration of a hole","title":"Geometry","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"The mesh is generated with Abaqus. Note, we have only the first order mesh loader and the higher order mesh is regenerated inside MetaFEM.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"element_shape = :CUBE\nsrc_fname = joinpath(@__DIR__, \"3D_Mesh.inp\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"To define the boundary (facets), there should be an more elegant interface later","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nL, err_scale = 5., 0.05\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L .+ err_scale)) .& (x2_mean .> (L .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L .+ err_scale)) .& (x3_mean .> (L .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nd1_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nd2_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_front; fem_domain = fem_domain) #left fixed\nd3_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_bottom; fem_domain = fem_domain) #left fixed\n\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_right, facet_IDs_top); fem_domain = fem_domain) #bot & right free\nloaded_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #top loadeds","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Physics","page":"Stress concentration of a hole","title":"Physics","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"Only 1/8 domain is simulated to use symmetry.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"E = 210e9\nν = 0.3\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 10000 * E / L ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_d1_fixed_bdy = τᵇ * Bilinear(d{1}, (dʷ{1} - d{1}))\n    WF_d2_fixed_bdy = τᵇ * Bilinear(d{2}, (dʷ{2} - d{2}))\n    WF_d3_fixed_bdy = τᵇ * Bilinear(d{3}, (dʷ{3} - d{3}))\n    WF_loaded_bdy = Bilinear(d{2}, σˡ{2,2} * n{2})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d1_fix_bg_ID, WF_d1_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d2_fix_bg_ID, WF_d2_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d3_fix_bg_ID, WF_d3_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, loaded_bg_ID, WF_loaded_bdy; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Assembly-and-Run","page":"Stress concentration of a hole","title":"Assembly & Run","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"Note, the code generated in \"compile_Updater_GPU\" is only used by \"update_OneStep\" so its position with the mesh update doesn't matter.","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_ILU, max_iter = 3000, max_pass = 20, s = 8)\nfem_domain.globalfield.converge_tol = 1e-8\nσ_external = 1\n\ncp = fem_domain.workpieces[1].mesh.controlpoints\ncp.σˡ2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#VTK","page":"Stress concentration of a hole","title":"VTK","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"\\\\\", \"3D_MetaFEM.vtk\"), wp)","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/#Bare-script","page":"Stress concentration of a hole","title":"Bare script","text":"","category":"section"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)\n\nelement_shape = :CUBE\nsrc_fname = joinpath(@__DIR__, \"3D_Mesh.inp\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nL, err_scale = 5., 0.05\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L .+ err_scale)) .& (x2_mean .> (L .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L .+ err_scale)) .& (x3_mean .> (L .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nd1_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nd2_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_front; fem_domain = fem_domain) #left fixed\nd3_fix_bg_ID = add_Boundary(wp_ID, facet_IDs_bottom; fem_domain = fem_domain) #left fixed\n\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_right, facet_IDs_top); fem_domain = fem_domain) #bot & right free\nloaded_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #top loadeds\n\nE = 210e9\nν = 0.3\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 10000 * E / L ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_d1_fixed_bdy = τᵇ * Bilinear(d{1}, (dʷ{1} - d{1}))\n    WF_d2_fixed_bdy = τᵇ * Bilinear(d{2}, (dʷ{2} - d{2}))\n    WF_d3_fixed_bdy = τᵇ * Bilinear(d{3}, (dʷ{3} - d{3}))\n    WF_loaded_bdy = Bilinear(d{2}, σˡ{2,2} * n{2})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d1_fix_bg_ID, WF_d1_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d2_fix_bg_ID, WF_d2_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, d3_fix_bg_ID, WF_d3_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, loaded_bg_ID, WF_loaded_bdy; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_ILU, max_iter = 3000, max_pass = 20, s = 8)\nfem_domain.globalfield.converge_tol = 1e-8\nσ_external = 1\n\ncp = fem_domain.workpieces[1].mesh.controlpoints\ncp.σˡ2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(string(@__DIR__, \"\\\\\", \"3D_MetaFEM.vtk\"), wp)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"","category":"page"},{"location":"examples/md/stress_concentration/stress_concentration/","page":"Stress concentration of a hole","title":"Stress concentration of a hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/lid_driven_cavity/lid_driven_cavity.jl\"","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Lid-driven-cavity","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Lid-driven cavity is perhaps the most well-known example in CFD like hello-world.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"(Image: cavity_flow)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The streamline is the Re = 1000 case and visualized in Paraview. The full source/data/visualization is here.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using MetaFEM\ndim = 2\nfem_domain = FEM_Domain(dim = dim)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Geometry","page":"Lid-driven cavity","title":"Geometry","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"L_box, e_number = 1., 40\ndomain_size = (L_box, L_box)\nelement_number = (e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Boundary","page":"Lid-driven cavity","title":"Boundary","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = L_box / e_number * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L_box .+ err_scale)) .& (x1_mean .> (L_box .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, vcat(sIDs_left, sIDs_bottom, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary(wp_ID, sIDs_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Physics","page":"Lid-driven cavity","title":"Physics","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Δx = L_box / e_number\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128 # 8, 16, 32\nτᵇ = μ / ρ * Cᵇ / Δx\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n    NS_boundary_BASE = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n\n    NS_boundary_DISP = ρ * Bilinear(u{i}, (uʷ{i} * uʷ{j} - u{i} * u{j}) * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +\n                        μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_FIX = ρ * Bilinear(u{i}, - u{i} * u{j} * n{j}) + Bilinear(p, - u{i} * n{i}) +\n                      μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_top = NS_boundary_BASE + NS_boundary_DISP\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, top_bg_ID, WF_boundary_top; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Assemble-and-Run","page":"Lid-driven cavity","title":"Assemble & Run","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\n@time begin\n    for wp in fem_domain.workpieces\n        update_Mesh(fem_domain.dim, wp, wp.element_space)\n    end\n    assemble_Global_Variables(fem_domain = fem_domain)\n    compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\nend\n\nfem_domain.linear_solver = solver_LU_CPU # CPU LU is practically faster\nfem_domain.globalfield.converge_tol = 1e-4\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\n@Takeout x1, x2, u1 FROM cpts\nis_occupied = cpts.is_occupied\ndx = L_box/e_number\n\nmid_cp_IDs = (x1 .> L_box/2 - 0.25 * dx) .& (x1 .< L_box/2 + 0.25 * dx)\nnum_y = x2[mid_cp_IDs]./L_box |> collect\nexp_us, exp_ys, num_us = [[] for i = 1:3]\nexp_labels, num_labels = [String[] for i =1:2]\n\nRe_arr = [100, 400, 1000, 3200, 5000]\nfor Re in Re_arr\n    u_st = Re / L_box * μ / ρ\n    fem_domain.globalfield.x .= 0.\n    fem_domain.globalfield.t = 0.\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n    tmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\n    for i = 1:tmax\n        cpts = fem_domain.workpieces[1].mesh.controlpoints\n        cp_IDs = findall(cpts.is_occupied)\n\n        u_top = u_st * (i / tmax)\n        dt = fem_domain.time_discretization.dt = 0.2 * Δx / u_top\n\n        cpts.uʷ1[cp_IDs] .= u_top\n        cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n        cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n        println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n        update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n        dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n    end\n    filename = string(\"Ghia_Re\", Re, \".csv\")\n    file_data = CSV.read(joinpath(@__DIR__, filename), DataFrame)\n\n    push!(num_us, collect(u1[mid_cp_IDs] ./ u_st))\n    push!(exp_us, collect(file_data.u))\n    push!(exp_ys, collect(file_data.y))\nend","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Visualization","page":"Lid-driven cavity","title":"Visualization","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"CSV files contain Ghia's data is also in the example folder.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using Plots\nfig = plot(; size=(800,800), title = \"Horizontal Velocity on Line x = 0.5\", xticks = -0.4:0.2:1, limits = (-0.5, 1.05, -0.05, 1.05), yticks = 0.0:0.1:1, xlabel = \"Normalized U₁\", ylabel = \"y\")\nfor i = 1:length(Re_arr)\n    color_val = (i / length(Re_arr) + 1) / 2\n    ids = sortperm(num_y)\n\n    scatter!(fig, exp_us[i], exp_ys[i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = string(\"Re $(Re_arr[i]), Ghia\"))\n    plot!(fig, num_us[i][ids], num_y[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = string(\"Re $(Re_arr[i]), MetaFEM\"))\nend\nfig.subplots[1].attr[:legend_position] = (0.7, 0.3)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Save the figure as .png file.","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"png(fig, joinpath(@__DIR__, \"2D_Ux_Plots.png\"))","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#VTK","page":"Lid-driven cavity","title":"VTK","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"fem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\nRe = 1000\nu_st = Re / L_box * μ / ρ\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ntmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\nfor i = 1:tmax\n    cpts = fem_domain.workpieces[1].mesh.controlpoints\n    cp_IDs = findall(cpts.is_occupied)\n\n    u_top = u_st * (i / tmax)\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / u_top\n\n    cpts.uʷ1[cp_IDs] .= u_top\n    cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n    cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n    println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(string(folder, \"\\\\\", \"2D_Cavity_Flow.vtk\"), wp)","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/#Bare-script","page":"Lid-driven cavity","title":"Bare script","text":"","category":"section"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using MetaFEM\ndim = 2\nfem_domain = FEM_Domain(dim = dim)\n\nL_box, e_number = 1., 40\ndomain_size = (L_box, L_box)\nelement_number = (e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Square(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)\n\n@Takeout (vertices, segments) FROM ref_mesh\nsIDs = get_BoundaryMesh(ref_mesh)\nv1IDs = segments.vertex_IDs[1, sIDs]\nv2IDs = segments.vertex_IDs[2, sIDs]\n\nx1_mean = (vertices.x1[v1IDs] .+ vertices.x1[v2IDs]) ./ 2\nx2_mean = (vertices.x2[v1IDs] .+ vertices.x2[v2IDs]) ./ 2\n\nerr_scale = L_box / e_number * 0.01\n\nsIDs_left = sIDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nsIDs_right = sIDs[(x1_mean .< (L_box .+ err_scale)) .& (x1_mean .> (L_box .- err_scale))]\nsIDs_bottom = sIDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nsIDs_top = sIDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, vcat(sIDs_left, sIDs_bottom, sIDs_right); fem_domain = fem_domain)\ntop_bg_ID = add_Boundary(wp_ID, sIDs_top; fem_domain = fem_domain)\n\nΔx = L_box / e_number\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128 # 8, 16, 32\nτᵇ = μ / ρ * Cᵇ / Δx\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n    NS_boundary_BASE = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n\n    NS_boundary_DISP = ρ * Bilinear(u{i}, (uʷ{i} * uʷ{j} - u{i} * u{j}) * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +\n                        μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_FIX = ρ * Bilinear(u{i}, - u{i} * u{j} * n{j}) + Bilinear(p, - u{i} * n{i}) +\n                      μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_top = NS_boundary_BASE + NS_boundary_DISP\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, top_bg_ID, WF_boundary_top; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\n@time begin\n    for wp in fem_domain.workpieces\n        update_Mesh(fem_domain.dim, wp, wp.element_space)\n    end\n    assemble_Global_Variables(fem_domain = fem_domain)\n    compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\nend\n\nfem_domain.linear_solver = solver_LU_CPU # CPU LU is practically faster\nfem_domain.globalfield.converge_tol = 1e-4\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\n@Takeout x1, x2, u1 FROM cpts\nis_occupied = cpts.is_occupied\ndx = L_box/e_number\n\nmid_cp_IDs = (x1 .> L_box/2 - 0.25 * dx) .& (x1 .< L_box/2 + 0.25 * dx)\nnum_y = x2[mid_cp_IDs]./L_box |> collect\nexp_us, exp_ys, num_us = [[] for i = 1:3]\nexp_labels, num_labels = [String[] for i =1:2]\n\nRe_arr = [100, 400, 1000, 3200, 5000]\nfor Re in Re_arr\n    u_st = Re / L_box * μ / ρ\n    fem_domain.globalfield.x .= 0.\n    fem_domain.globalfield.t = 0.\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n    tmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\n    for i = 1:tmax\n        cpts = fem_domain.workpieces[1].mesh.controlpoints\n        cp_IDs = findall(cpts.is_occupied)\n\n        u_top = u_st * (i / tmax)\n        dt = fem_domain.time_discretization.dt = 0.2 * Δx / u_top\n\n        cpts.uʷ1[cp_IDs] .= u_top\n        cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n        cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n        println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n        update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n        dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n    end\n    filename = string(\"Ghia_Re\", Re, \".csv\")\n    file_data = CSV.read(joinpath(@__DIR__, filename), DataFrame)\n\n    push!(num_us, collect(u1[mid_cp_IDs] ./ u_st))\n    push!(exp_us, collect(file_data.u))\n    push!(exp_ys, collect(file_data.y))\nend\n\nusing Plots\nfig = plot(; size=(800,800), title = \"Horizontal Velocity on Line x = 0.5\", xticks = -0.4:0.2:1, limits = (-0.5, 1.05, -0.05, 1.05), yticks = 0.0:0.1:1, xlabel = \"Normalized U₁\", ylabel = \"y\")\nfor i = 1:length(Re_arr)\n    color_val = (i / length(Re_arr) + 1) / 2\n    ids = sortperm(num_y)\n\n    scatter!(fig, exp_us[i], exp_ys[i], markershape = :rect, markersize = 6, color = RGBA(color_val, 0, 0, 1), label = string(\"Re $(Re_arr[i]), Ghia\"))\n    plot!(fig, num_us[i][ids], num_y[ids], markershape = :circle, markersize = 3, color = RGBA(0, 0.5, color_val, 1), markercolor = RGBA(0, 0.5, color_val, 1), label = string(\"Re $(Re_arr[i]), MetaFEM\"))\nend\nfig.subplots[1].attr[:legend_position] = (0.7, 0.3)\n\npng(fig, joinpath(@__DIR__, \"2D_Ux_Plots.png\"))\n\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\nRe = 1000\nu_st = Re / L_box * μ / ρ\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ntmax = Re > 1000 ? 10 : ceil(Re / 100) |> Int\nfor i = 1:tmax\n    cpts = fem_domain.workpieces[1].mesh.controlpoints\n    cp_IDs = findall(cpts.is_occupied)\n\n    u_top = u_st * (i / tmax)\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / u_top\n\n    cpts.uʷ1[cp_IDs] .= u_top\n    cpts.τᵐ[cp_IDs] .= (4 / dt ^ 2 + 9 * 16 * ν ^ 2 * dim * Δx ^ (-4) .+ Δx ^ (-2) * (cpts.u1[cp_IDs] .^ 2. + cpts.u2[cp_IDs] .^ 2.)) .^ (-0.5)\n    cpts.τᶜ[cp_IDs] .= (cpts.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n\n    println(\"Timestep \", i, \" velocity = \", u_top, \" tol = \", fem_domain.globalfield.converge_tol)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(string(folder, \"\\\\\", \"2D_Cavity_Flow.vtk\"), wp)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"page"},{"location":"examples/md/lid_driven_cavity/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MetaFEM.jl","page":"Home","title":"MetaFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to MetaFEM, a GPU-accelerated generic finite element solver by meta-expressions. ","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Function-wise, MetaFEM is similar to a skeleton version of FEniCS or FreeFEM, i.e., MetaFEM takes in some high-level mathematical expressions (PDE weak-forms) and a mesh, e.g., thermal conduction in a pikachu, then outputs the corresponding simulation, e.g., to VTK files, resulting in something similar to the logo through common softwares like Paraview. Different from the classical approaches, however, MetaFEM uses only the most fundamental concepts, i.e., tensor components added, multiplied or algebraically operated in the variational form(s). There is no RHS/LHS, no Dirichlet boundary, no helper functions like grad/nabla, etc., but only the variational residue in the component form.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Software-wise, MetaFEM is an original implementation from nearly scratch, i.e., MetaFEM is natively coded in Julia directly based on CUDA.jl, with the indirect adaptations from the other two external libraries: MacroTools.jl and IterativeSolvers.jl. MetaFEM V0.1.0 contains ~5000 lines of code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MetaFEM contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rule-based Computer Algebra System (CAS), i.e., symbolic differentiation and simplification;\nA 2D/3D mesh system, with simplex/cube Lagrangian elements at arbitrary order and cubic serendipity elements at either order 2 or 3;\nA FEM kernel which assembles everything and generates the code; and\nThe infrastructure to put the simulation on GPU.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Examples of 2D/3D thermal conduction, linear elasticity and incompressible flow are readily usable. The commented examples starting with the pikachu case are here while the source files with all/most relevant data can be found here, which can be a good starting point if you want a quick try and don't want to read the rest of the document.  In each subfolder of the source files, the *.jl file is the main script that actually works. Paraview state file(s) *.pvsm may be also helpful for quick visualization, by open Paraview-File-Load State.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nMetaFEM is under development. Any input, e.g., questions of usage, bugs, feature requests, or any ideas to make it better, will be very welcomed. Please feel free to open an issue on Github or directly email me at jiaxixie2022@u.northwestern.edu.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Through REPL-Pkg, i.e., Press ] in Julia REPL to enter pkg>, then:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MetaFEM","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or directly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MetaFEM\")","category":"page"}]
}
