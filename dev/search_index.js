var documenterSearchIndex = {"docs":
[{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cylinderflow/cylinderflow.jl\"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Incompressible-flow-pass-a-cylinder","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"In this example we simulate a flow case like this (Image: flow) First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"using MetaFEM\ndim = 3\nfem_domain = FEM_Domain(; dim = dim)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Geometry","page":"Incompressible flow pass a cylinder","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Load the mesh \"3D_COMSOL_Mesh.mphtxt\" which can be found in here and should be put under the same directory of the script.","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"L = 2.5\nH = 0.41\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Define boundary:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = 0.01\n\nis_left = (x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))\nis_right = (x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, facet_IDs[.~(is_left .| is_right)]; fem_domain = fem_domain)\ninflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_left]; fem_domain = fem_domain)\noutflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_right]; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Physics","page":"Incompressible flow pass a cylinder","title":"Physics","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"The steady state Navier-Stokes (NS) equation with Streamline-Upwind/Peterove-Galerkin (SUPG) stabilization can be formed as follows:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"textvariablequad u_ipqquadtextparametersquadrhomuu^W_itau^btau^ctau^m","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Rccoloneqq u_kkqquad Rm_icoloneqqrho u_ku_ik+p_i-mu u_ikk","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"overbrace-rho(u_iju_iu_j)-(u_iip)+(pu_ii)+mu(u_iju_ij)^NS+overbracetau^mrho(u_ijRm_iu_j)+tau^m(p_iRm_i)+tau^c(u_iiRc)^SUPG =0qquad inquadOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(u_ipn_i)-mu(u_iu_ijn_j)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu^w_iu^w_jn_j)+(p(u^w_i-u_i)n_i)+mu(u_ij(u^w_i-u_i)n_j)+tau^brho(u_iu_i-u^w_i)=0qquad onquad(partialOmega)_inflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"rho(u_iu_iu_jn_j)=0qquad onquad(partialOmega)_outflow","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"(p-u_in_i)+mu(u_ij-u_in_j)+tau^brho(u_iu_i)=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"where u_iprhomu are the velocity, pressure, density and the dynamic viscosity respectively. The code is:","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"Δx = 0.02 # r = 0.1\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128\nτᵇ = μ / ρ * Cᵇ / Δx\nτᵖ = Cᵇ * Δx / μ\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n\n    NS_boundary_BASE = Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n    NS_boundary_INFLOW = ρ * Bilinear(u{i}, uʷ{i} * uʷ{j} * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +  μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_OUTFLOW = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + τᵖ * Bilinear(p, p)\n    NS_boundary_FIX = Bilinear(p, - u{i} * n{i}) + μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_inflow = NS_boundary_BASE + NS_boundary_INFLOW\n    WF_boundary_outflow = NS_boundary_BASE + NS_boundary_OUTFLOW\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, inflow_bg_ID, WF_boundary_inflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, outflow_bg_ID, WF_boundary_outflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Assemble","page":"Incompressible flow pass a cylinder","title":"Assemble","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"initialize_LocalAssembly(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_order = 2, itg_order = 6, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Run!","page":"Incompressible flow pass a cylinder","title":"Run!","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_Jacobi, max_iter = 5000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-5\n\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n@Takeout (controlpoints, facets, elements) FROM fem_domain.workpieces[1].mesh\ncp_IDs = findall(controlpoints.is_occupied)\nys = controlpoints.x2[cp_IDs]\nzs = controlpoints.x3[cp_IDs]\nUm = 0.45\ncontrolpoints.uʷ1[cp_IDs] .= (16 * Um / H ^ 4) .* (ys .* zs .* (H .- ys) .* (H .- zs))\n\ntmax = 1\nfor i = 1:tmax\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / Um\n\n    controlpoints.τᵐ[cp_IDs] .= (9 * 16 * ν ^ 2 * dim * Δx ^ (-4)) ^ (-0.5)\n    controlpoints.τᶜ[cp_IDs] .= (controlpoints.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Save-to-VTK","page":"Incompressible flow pass a cylinder","title":"Save to VTK","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"wp = fem_domain.workpieces[1]\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), wp)","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/#Bare-script","page":"Incompressible flow pass a cylinder","title":"Bare script","text":"","category":"section"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"using MetaFEM\ndim = 3\nfem_domain = FEM_Domain(; dim = dim)\n\nL = 2.5\nH = 0.41\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = 0.01\n\nis_left = (x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))\nis_right = (x1_mean .< (L .+ err_scale)) .& (x1_mean .> (L .- err_scale))\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfixed_bg_ID = add_Boundary(wp_ID, facet_IDs[.~(is_left .| is_right)]; fem_domain = fem_domain)\ninflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_left]; fem_domain = fem_domain)\noutflow_bg_ID = add_Boundary(wp_ID, facet_IDs[is_right]; fem_domain = fem_domain)\n\nΔx = 0.02 # r = 0.1\nρ = 1e3\nμ = 1.\nν = μ / ρ\nCᵇ = 128\nτᵇ = μ / ρ * Cᵇ / Δx\nτᵖ = Cᵇ * Δx / μ\n\n@Sym u p\n@External_Sym (uʷ, CONTROLPOINT_VAR) (τᵐ, CONTROLPOINT_VAR) (τᶜ, CONTROLPOINT_VAR)\n\n@Def begin\n    Rc = u{m;m}\n    Rm{i} = u{m} * u{i;m} + p{;i} / ρ - μ / ρ * u{i;m,m}\nend\n\n@Def begin\n    NS_domain_BASE = - ρ * Bilinear(u{i;j}, u{i} * u{j}) - Bilinear(u{i;i}, p) + Bilinear(p, u{i;i}) + μ * Bilinear(u{i;j}, u{i;j})\n    NS_domain_SUPG = τᵐ * ρ * Bilinear(u{i;j}, Rm{i} * u{j}) + τᵐ * Bilinear(p{;i}, Rm{i}) + τᶜ * ρ * Bilinear(u{i;i}, Rc)\n\n    NS_boundary_BASE = Bilinear(u{i}, p * n{i}) - μ * Bilinear(u{i}, u{i;j} * n{j})\n    NS_boundary_INFLOW = ρ * Bilinear(u{i}, uʷ{i} * uʷ{j} * n{j}) + Bilinear(p, (uʷ{i} - u{i}) * n{i}) +  μ * Bilinear(u{i;j}, (uʷ{i} - u{i}) * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i} - uʷ{i})\n\n    NS_boundary_OUTFLOW = ρ * Bilinear(u{i}, u{i} * u{j} * n{j}) + τᵖ * Bilinear(p, p)\n    NS_boundary_FIX = Bilinear(p, - u{i} * n{i}) + μ * Bilinear(u{i;j}, - u{i} * n{j}) + τᵇ * ρ * Bilinear(u{i}, u{i})\nend\n\n@Def begin\n    WF_domain = NS_domain_BASE + NS_domain_SUPG\n    WF_boundary_inflow = NS_boundary_BASE + NS_boundary_INFLOW\n    WF_boundary_outflow = NS_boundary_BASE + NS_boundary_OUTFLOW\n    WF_boundary_fix = NS_boundary_BASE + NS_boundary_FIX\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, inflow_bg_ID, WF_boundary_inflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, outflow_bg_ID, WF_boundary_outflow; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fixed_bg_ID, WF_boundary_fix; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain; explicit_max_sd_order = 1)\nmesh_Classical([wp_ID]; shape = element_shape, itp_order = 2, itg_order = 6, fem_domain = fem_domain)\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(fem_domain = fem_domain)\nfem_domain.linear_solver = x -> solver_IDRs(x; Pl_func = precondition_CUDA_Jacobi, max_iter = 5000, max_pass = 10, s = 8)\nfem_domain.globalfield.converge_tol = 1e-5\n\nfem_domain.globalfield.x .= 0.\nfem_domain.globalfield.t = 0\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\n@Takeout (controlpoints, facets, elements) FROM fem_domain.workpieces[1].mesh\ncp_IDs = findall(controlpoints.is_occupied)\nys = controlpoints.x2[cp_IDs]\nzs = controlpoints.x3[cp_IDs]\nUm = 0.45\ncontrolpoints.uʷ1[cp_IDs] .= (16 * Um / H ^ 4) .* (ys .* zs .* (H .- ys) .* (H .- zs))\n\ntmax = 1\nfor i = 1:tmax\n    dt = fem_domain.time_discretization.dt = 0.2 * Δx / Um\n\n    controlpoints.τᵐ[cp_IDs] .= (9 * 16 * ν ^ 2 * dim * Δx ^ (-4)) ^ (-0.5)\n    controlpoints.τᶜ[cp_IDs] .= (controlpoints.τᵐ[cp_IDs] .* (dim * Δx ^ (-2))) .^ (-1.)\n    update_OneStep(fem_domain.time_discretization; max_iter = 6, fem_domain = fem_domain)\n    dessemble_X(fem_domain.workpieces, fem_domain.globalfield)\nend\n\nwp = fem_domain.workpieces[1]\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), wp)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"","category":"page"},{"location":"examples/md/cylinderflow/cylinderflow/","page":"Incompressible flow pass a cylinder","title":"Incompressible flow pass a cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/cantilever/cantilever.jl\"","category":"page"},{"location":"examples/md/cantilever/cantilever/#Linear-elastic-cantilever-bending","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"In this example we simulate a cantilever beam under different loads. First, we load the package and declare the domain:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Geometry","page":"Linear elastic cantilever bending","title":"Geometry","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"For cuboid geometry we have helper functions \"make_Square\" and \"make_Brick\" for 2D/3D:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"L_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Brick(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Defining boundary can be a little lengthy because we need to find those IDs. Any idea for improvement will be very welcomed.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top); fem_domain = fem_domain) #bottom & right & front free\nback_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #back will be loaded\nright_bg_ID = add_Boundary(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded","category":"page"},{"location":"examples/md/cantilever/cantilever/#Physics","page":"Linear elastic cantilever bending","title":"Physics","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The mathematical formulation is:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"textvariablequad d_iqquadtextparametersquad Enud^w_isigma^l_ijtau","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"lambda=fracEnu(1+nu)(1-2nu)qquadmu=fracE2(1+nu)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"epsilon_ij=fracd_ij+d_ji2qquadsigma_ij=lambdadelta_ijepsilon_mm+2muepsilon_ij","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"-(d_ijsigma_ij)=0qquad inquadOmega","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_isigma^l_ijn_j)=0qquad onquad(partialOmega)_load","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(d_itau(d^w_i-d_i))=0qquad onquad(partialOmega)_fix","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"where d_iEnulambdamuepsilon_ijsigma_ij are the displacement, Young’s modulus, Poisson ratio, Lame's first parameter, shear modulus, strain and stress, respectively.","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"The code is: (Note, if we set the Poisson ratio ν = 0.0, the spherical part, i.e., λ related terms, will be actaully removed by the simplification.)","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"Δx = L_box / e_number\nE = 1\nν = 0.001\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (σ², CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n\n    WF_right_bdy = Bilinear(d{i}, σˡ{i,j} * n{j})\n    WF_back_bdy = Bilinear(d{i}, σ²{i,j} * n{j})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, back_bg_ID, WF_back_bdy; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Assembly","page":"Linear elastic cantilever bending","title":"Assembly","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"initialize_LocalAssembly(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Run","page":"Linear elastic cantilever bending","title":"Run","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"we run for three different loading conditions:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ndx = L_box/e_number\nh, l = L_box, (L_box * LW_ratio)\nI = 1/12 * h ^ 3\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nhorizontal_mid_cp_IDs = findall((cpts.x2 .> L_box / 2 - err_scale * dx) .& (cpts.x2 .< L_box / 2 + err_scale * dx) .&\n                                (cpts.x3 .> L_box / 2 - err_scale * dx) .& (cpts.x3 .< L_box / 2 + err_scale * dx))\n\nx_plot = cpts.x1[horizontal_mid_cp_IDs] |> collect\nsorted_ids = sortperm(x_plot)\n\nhorizontal_mid_cp_IDs = horizontal_mid_cp_IDs[MetaFEM.cu(sorted_ids)]\nx_plot = x_plot[sorted_ids]\ny_plots = [[] for i = 1:2]\nplot_labels = [String[] for i = 1:2]\n\nσ_external = 1e6\ncpts.σˡ6 .= σ_external\ncpts.σ²2 .= 0\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external * L_box/(6 * E * I) * (3 * l .-  x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Concentrated load, analytical\")\npush!(plot_labels[2], \"Concentrated load, MetaFEM\")\n\ncpts.σˡ6 .= 0\ncpts.σ²2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (24 * E * I) * (x_plot.^2 .+ 6 * l ^ 2 .- 4 * l .* x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Uniform pressure, analytical\")\npush!(plot_labels[2], \"Uniform pressure, MetaFEM\")\n\ncpts.σ²2 .= σ_external .* (1. .- cpts.x1 ./ (L_box * LW_ratio))\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (120 * l * E * I) * (10 * l ^ 3 .- 10 * l^2 .* x_plot .+ 5 * l * x_plot .^ 2 .- x_plot .^ 3) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Linearly distributed pressure, analytical\")\npush!(plot_labels[2], \"Linearly distributed pressure, MetaFEM\")","category":"page"},{"location":"examples/md/cantilever/cantilever/#Plot","page":"Linear elastic cantilever bending","title":"Plot","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"With Makie.jl:","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using CairoMakie, Colors\n\nfig = Figure(resolution = (1400, 900))\nax1 = fig[1, 1] = Axis(fig, title = \"Normalized deflection on the line y = z = 0.5\",\n                    xlims = (0., 10.0), xticks = 0:2:10, ylims = (0, 1), yticks = 0:0.2:1, xlabel = \"x\", ylabel = \"Normalized d₂\")\nfontsize = 24\nax1.titlesize = fontsize\nax1.xlabelsize = fontsize\nax1.ylabelsize = fontsize\n\nplots = [[] for i = 1:2]\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][1], marker = '■', markersize = 10px, color = :blue)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][1], marker = :circle, markersize = 5px, color = :red, markercolor = :red)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][2], marker = '■', markersize = 10px, color = :gray)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][2], marker = :circle, markersize = 5px, color = :brown, markercolor = :brown)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][3], marker = '■', markersize = 10px, color = :green)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][3], marker = :circle, markersize = 5px, color = :purple, markercolor = :purple)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nLegend(fig, vcat(plots...), vcat(plot_labels...), bbox = (300, 500, 600, 800), labelsize = fontsize)\nfig","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"(Image: cantilever)","category":"page"},{"location":"examples/md/cantilever/cantilever/#Bare-script","page":"Linear elastic cantilever bending","title":"Bare script","text":"","category":"section"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"using MetaFEM\nfem_domain = FEM_Domain(dim = 3)\n\nL_box, e_number, LW_ratio = 1., 4, 10\ndomain_size = (L_box * LW_ratio, L_box, L_box)\nelement_number = (Int(e_number * LW_ratio / 4), e_number, e_number)\nelement_shape = :CUBE\n\nvertices, connections = make_Brick(domain_size, element_number, element_shape)\nref_mesh = construct_TotalMesh(vertices, connections)\n\n@Takeout (vertices, faces) FROM ref_mesh\nfacet_IDs = get_BoundaryMesh(ref_mesh)\nvIDs = faces.vertex_IDs[:, facet_IDs]\n\nx1_mean = vec(sum(vertices.x1[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx2_mean = vec(sum(vertices.x2[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\nx3_mean = vec(sum(vertices.x3[vIDs], dims = 1)) ./ size(faces.vertex_IDs, 1)\n\nerr_scale = L_box / e_number * 0.01\n\nfacet_IDs_left = facet_IDs[(x1_mean .< err_scale) .& (x1_mean .> (.- err_scale))]\nfacet_IDs_right = facet_IDs[(x1_mean .< (L_box * LW_ratio .+ err_scale)) .& (x1_mean .> (L_box * LW_ratio.- err_scale))]\nfacet_IDs_front = facet_IDs[(x2_mean .< err_scale) .& (x2_mean .> (.- err_scale))]\nfacet_IDs_back = facet_IDs[(x2_mean .< (L_box .+ err_scale)) .& (x2_mean .> (L_box .- err_scale))]\nfacet_IDs_bottom = facet_IDs[(x3_mean .< err_scale) .& (x3_mean .> (.- err_scale))]\nfacet_IDs_top = facet_IDs[(x3_mean .< (L_box .+ err_scale)) .& (x3_mean .> (L_box .- err_scale))]\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\nfix_bg_ID = add_Boundary(wp_ID, facet_IDs_left; fem_domain = fem_domain) #left fixed\nfree_bg_ID = add_Boundary(wp_ID, vcat(facet_IDs_front, facet_IDs_bottom, facet_IDs_top); fem_domain = fem_domain) #bottom & right & front free\nback_bg_ID = add_Boundary(wp_ID, facet_IDs_back; fem_domain = fem_domain) #back will be loaded\nright_bg_ID = add_Boundary(wp_ID, facet_IDs_right; fem_domain = fem_domain) #top will be loaded\n\nΔx = L_box / e_number\nE = 1\nν = 0.001\nλ = E * ν / ((1 + ν) * (1 - 2 * ν))\nμ = E / (2 * (1 + ν))\nτᵇ = 1000 * E / L_box ^ 2\n\n@Sym d\n@External_Sym (dʷ, CONTROLPOINT_VAR) (σˡ, CONTROLPOINT_VAR, SYMMETRIC_TENSOR) (σ², CONTROLPOINT_VAR, SYMMETRIC_TENSOR)\n@Def ε{i,j} = (d{i;j} + d{j;i}) / 2.\n@Def σ{i,j} = λ * δ{i,j} * ε{m,m} + 2. * μ * ε{i,j}\n@Def Elastrostatic_Domain = - Bilinear(ε{i,j}, σ{i,j})\n\n@Def begin\n    WF_domain = Elastrostatic_Domain\n    WF_fixed_bdy = τᵇ * Bilinear(d{i}, (dʷ{i} - d{i}))\n\n    WF_right_bdy = Bilinear(d{i}, σˡ{i,j} * n{j})\n    WF_back_bdy = Bilinear(d{i}, σ²{i,j} * n{j})\nend\n\nassign_WorkPiece_WeakForm(wp_ID, WF_domain; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, fix_bg_ID, WF_fixed_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, right_bg_ID, WF_right_bdy; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, back_bg_ID, WF_back_bdy; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain)\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\ncompile_Updater_GPU(; domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\nassemble_Global_Variables(; fem_domain = fem_domain)\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ndx = L_box/e_number\nh, l = L_box, (L_box * LW_ratio)\nI = 1/12 * h ^ 3\nerr_scale = 0.25\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\nhorizontal_mid_cp_IDs = findall((cpts.x2 .> L_box / 2 - err_scale * dx) .& (cpts.x2 .< L_box / 2 + err_scale * dx) .&\n                                (cpts.x3 .> L_box / 2 - err_scale * dx) .& (cpts.x3 .< L_box / 2 + err_scale * dx))\n\nx_plot = cpts.x1[horizontal_mid_cp_IDs] |> collect\nsorted_ids = sortperm(x_plot)\n\nhorizontal_mid_cp_IDs = horizontal_mid_cp_IDs[MetaFEM.cu(sorted_ids)]\nx_plot = x_plot[sorted_ids]\ny_plots = [[] for i = 1:2]\nplot_labels = [String[] for i = 1:2]\n\nσ_external = 1e6\ncpts.σˡ6 .= σ_external\ncpts.σ²2 .= 0\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external * L_box/(6 * E * I) * (3 * l .-  x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Concentrated load, analytical\")\npush!(plot_labels[2], \"Concentrated load, MetaFEM\")\n\ncpts.σˡ6 .= 0\ncpts.σ²2 .= σ_external\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (24 * E * I) * (x_plot.^2 .+ 6 * l ^ 2 .- 4 * l .* x_plot) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Uniform pressure, analytical\")\npush!(plot_labels[2], \"Uniform pressure, MetaFEM\")\n\ncpts.σ²2 .= σ_external .* (1. .- cpts.x1 ./ (L_box * LW_ratio))\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\ny_plot_ana = σ_external / (120 * l * E * I) * (10 * l ^ 3 .- 10 * l^2 .* x_plot .+ 5 * l * x_plot .^ 2 .- x_plot .^ 3) .* x_plot .^ 2\ny_plot_num = cpts.d2[horizontal_mid_cp_IDs] |> collect\ny_max = maximum(y_plot_ana)\n\npush!(y_plots[1], y_plot_ana ./ y_max)\npush!(y_plots[2], y_plot_num ./ y_max)\npush!(plot_labels[1], \"Linearly distributed pressure, analytical\")\npush!(plot_labels[2], \"Linearly distributed pressure, MetaFEM\")\n\nusing CairoMakie, Colors\n\nfig = Figure(resolution = (1400, 900))\nax1 = fig[1, 1] = Axis(fig, title = \"Normalized deflection on the line y = z = 0.5\",\n                    xlims = (0., 10.0), xticks = 0:2:10, ylims = (0, 1), yticks = 0:0.2:1, xlabel = \"x\", ylabel = \"Normalized d₂\")\nfontsize = 24\nax1.titlesize = fontsize\nax1.xlabelsize = fontsize\nax1.ylabelsize = fontsize\n\nplots = [[] for i = 1:2]\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][1], marker = '■', markersize = 10px, color = :blue)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][1], marker = :circle, markersize = 5px, color = :red, markercolor = :red)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][2], marker = '■', markersize = 10px, color = :gray)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][2], marker = :circle, markersize = 5px, color = :brown, markercolor = :brown)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nana_plot = scatter!(ax1, x_plot, y_plots[1][3], marker = '■', markersize = 10px, color = :green)\nnum_plot = scatterlines!(ax1, x_plot, y_plots[2][3], marker = :circle, markersize = 5px, color = :purple, markercolor = :purple)\npush!(plots[1], ana_plot)\npush!(plots[2], num_plot)\n\nLegend(fig, vcat(plots...), vcat(plot_labels...), bbox = (300, 500, 600, 800), labelsize = fontsize)\nfig\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"","category":"page"},{"location":"examples/md/cantilever/cantilever/","page":"Linear elastic cantilever bending","title":"Linear elastic cantilever bending","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"EditURL = \"https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/pikachu/pikachu.jl\"","category":"page"},{"location":"examples/md/pikachu/pikachu/#Thermal-conduction-in-a-pikachu","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Let's begin with simulating the temperature distribution on a pikachu. First, we load the package by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"using MetaFEM","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we define a \"FEM_Domain\" of dimension 3, which will finally turn to one linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain = FEM_Domain(; dim = 3)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Geometry","page":"Thermal conduction in a pikachu","title":"Geometry","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Every FEM simulation needs a mesh. In MetaFEM we need to read mesh as (vert, connections). \"vert\" is a dim times N_n CuArray of coordinates, where N_n is the number of nodes, while \"connections\" is a N_v times N_e CuArray of sequenced node IDs where N_v is the number of nodes in each element and N_e is the total element number, very similar to the mesh loading process in other fields, e.g., for plotting. The input mesh is assumed to be at first order, i.e., every node is the end of some edges. Higher order elements will be regenerated inside MetaFEM based on the first order mesh.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Here we read the mesh from file 3D_COMSOL_Mesh.mphtxt generated by COMSOL, which can be found here and should be copied to the same folder as your script. The vertices coordinates are divided by 100 here because our pikachu has his length scale in cm. As for the function names, the mesh of the body is named a TotalMesh, in contrast to BoundaryMesh which only contains the boundary nodes/edges/faces","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"element_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we add a \"workpiece\", an object which will be assigned physics later, to our FEM_Domain, which returns wp_ID (the workpiece ID) for later reference by simply \"fem_domain.workpieces[wp_ID]\". Multiple workpieces in the same domain will be solved in coupling as a monolithic linear system Kx = d.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"wp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to define boundary. We call \"get_BoundaryMesh\" to return all the IDs for the boundary faces (segments in 2D domain). We assign all of them as one boundary, assuming our pikachu is under convection in homogeneous air.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Physics","page":"Thermal conduction in a pikachu","title":"Physics","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we are going to define physics, the most joyful part of the code. On the one hand, the mathematical formulation for the heat conduction in the pikachu Omega with convection on partialOmega is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"textvariablequad Tqquadtextparametersquad CkhT_envs","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"-k(T_iT_i)+(Ts)=0qquad inquadOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"h(TT_env-T)=0qquad onquadpartialOmega","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"where T is the body temperature, C is the volumetric heat capacity, k is the thermal conductivity, h is the convective coefficient, T_env is the environment (air) temperature, s is the heat source.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"On the other hand, the code is:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"C = 1.\nk = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Fairly self-illustrative, isn't it? Remarks:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"C, k, h, T_env are just Julia native variable, i.e., floating-point numbers;\ns is an external variable, which means they will not be differentiated and allocated in the final linear system Kx=d, but they will have a number per workpiece controlpoint (alias for the FEM mesh vertex, in contrast to the first order mesh nodes we used to describe the geometry).\nMetaFEM has default variable declaration of the following code (as in here). So we do not define T again. Also, only the variables which are actually in use (in a weak-form assigned to a workpiece) will be allocated;","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (x, CONTROLPOINT_VAR) (y, CONTROLPOINT_VAR) (z, CONTROLPOINT_VAR) (t, GLOBAL_VAR) (dt, GLOBAL_VAR)\n@External_Sym (F, INTEGRATION_POINT_VAR) (f, INTEGRATION_POINT_VAR) (n, INTEGRATION_POINT_VAR) δ\n@Sym u p T","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"By @Def, the expressions are parsed. The basic unit for FEM weak-form is a bilinear form, denoted by the function \"Bilinear\". The symbols or numbers in curly bracket define the subscripts. The semicolon \";\" in code is the comma \",\" in math separating the component index and the derivatives while the comma \",\" in code is just a separator betweewn symbols. The symbol \"t\" is reserved only for the derivative index to denote the time derivative. Note, a Julia variable like k is evaluated and fixed in @Def parsing, so if we want a changeable k, we should use:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"@External_Sym (k, GLOBAL_VAR)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"The system understands free/dumb indices so the script should look just like something one may write on the blackboard in a mechanics class.\nWe do not have fixed high-level concepts like \"Dirichlet/Neumann/Robin/... boundary\", everything is just a weak-form, capable of full customization;\n\"assign_WorkPiece_WeakForm\" assigns heat_dissipation to the wp_ID workpiece of the domain fem_domain and \"assign_Boundary_WeakForm\" assigns conv_boundary to the flux_bg_ID boundary of the the wp_ID workpiece of the domain fem_domain.","category":"page"},{"location":"examples/md/pikachu/pikachu/#Assembly","page":"Thermal conduction in a pikachu","title":"Assembly","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"After defining physics, we need to collect, classify and number all the variables each workpiece. Although there is a shorter version:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"initialize_LocalAssembly(fem_domain::FEM_Domain; explicit_max_sd_order::Integer) = initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"we still prefer to the following way which defines explicitly the maximum spatial differential order per workpiece, i.e., weak-form spatial derivatives order higher than \"explicit_max_sd_order\" will not be stored to save memory. Memory usage for interpolation points ~ (order + 1)^dim, e.g., 2-order to 1-order in 3D has a 27 to 8 memory usage difference.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we regenerate our mesh to second order serendipity elements with fifth Gaussian quadrature. Note, \"mesh_Classical\" needs to know variables so it must be after \"initialize_LocalAssembly\".","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Also we need to generate the simulation codes, where \"domain_ID\" is just used to generated function symbol.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Run-and-Output","page":"Thermal conduction in a pikachu","title":"Run & Output","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Now we are ready for simulation! First update geometry information such as the Jacobians/interpolation values/... by:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"for wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Then we allocate the K x text and  d:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"assemble_Global_Variables(fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"We also need to choose a linear solver. For a small-sized problem, CPU solver, defined here using LinearAlgebra.lu, is actually faster, although the data will still be passed to GPU anyway.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"fem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Assign initial values and external variables:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"cpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn't need initial values, but just for completeness. The default initial values are zeros.\ncpts.s[cp_IDs] .= 1600.","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Solve K(Delta x) = d and do x += Delta x:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"update_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Pull global x to local variables. (Pushing local to global is included in \"update_OneStep\"):","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"dessemble_X(fem_domain.workpieces, fem_domain.globalfield)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"Save to vtk, note, scale is only for length:","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"write_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), fem_domain.workpieces[1]; scale = 100)","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"(Image: pika2)","category":"page"},{"location":"examples/md/pikachu/pikachu/#Bare-script","page":"Thermal conduction in a pikachu","title":"Bare script","text":"","category":"section"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"using MetaFEM\n\nfem_domain = FEM_Domain(; dim = 3)\n\nelement_shape = :SIMPLEX\nsrc_fname = joinpath(@__DIR__, \"3D_COMSOL_Mesh.mphtxt\")\nvert, connections = read_Mesh(src_fname)\nref_mesh = construct_TotalMesh(vert ./ 100, connections)\n\nwp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)\n\nfIDs = get_BoundaryMesh(ref_mesh)\nflux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)\n\nC = 1.\nk = 0.6\nh = 25.\nTₑₙᵥ = 273.15 + 20\n\n@External_Sym (s, CONTROLPOINT_VAR)\n@Def begin\n    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)\n    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)\nend\nassign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)\nassign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)\n\ninitialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)\n\nmesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)\n\ncompile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)\n\nfor wp in fem_domain.workpieces\n    update_Mesh(fem_domain.dim, wp, wp.element_space)\nend\n\nassemble_Global_Variables(fem_domain = fem_domain)\n\nfem_domain.linear_solver = solver_LU_CPU\nfem_domain.globalfield.converge_tol = 1e-5\n\ncpts = fem_domain.workpieces[1].mesh.controlpoints\ncp_IDs = findall(cpts.is_occupied)\ncpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn't need initial values, but just for completeness. The default initial values are zeros.\ncpts.s[cp_IDs] .= 1600.\n\nupdate_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)\n\ndessemble_X(fem_domain.workpieces, fem_domain.globalfield)\n\nwrite_VTK(joinpath(@__DIR__, \"3D_MetaFEM_Result.vtk\"), fem_domain.workpieces[1]; scale = 100)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"","category":"page"},{"location":"examples/md/pikachu/pikachu/","page":"Thermal conduction in a pikachu","title":"Thermal conduction in a pikachu","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MetaFEM.jl","page":"Home","title":"MetaFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to MetaFEM, a GPU-accelerated generic finite element solver by meta-expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Function-wise, MetaFEM is similar to a skeleton version of FEniCS or FreeFEM, i.e., MetaFEM takes in some high-level mathematical expressions (PDE weak-forms) and a mesh, e.g., thermal conduction in a pikachu, then outputs the corresponding simulation, e.g., to VTK files, resulting in something similar to the logo through common softwares like Paraview. Different from the classical approaches, MetaFEM uses only the most fundamental concepts, i.e., tensor components added, multiplied or algebraically operated together. There is no RHS/LHS, no Dirichlet boundary, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Software-wise, MetaFEM is an original implementation from nearly scratch, i.e., MetaFEM is natively coded in Julia directly based on CUDA.jl, with the indirect adaptations from the other two external libraries: MacroTools.jl and IterativeSolvers.jl. MetaFEM V0.1.0 contains ~5000 lines of code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MetaFEM contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rule-based Computer Algebra System (CAS), i.e., symbolic differentiation and simplification;\nA 2D/3D mesh system, with simplex/cube Lagrangian elements at arbitrary order and cubic serendipity elements at either order 2 or 3;\nA FEM kernel that assembles everything and generates the code; and\nThe infrastructure to put the simulation on GPU.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Examples of 2D/3D thermal conduction, linear elasticity and incompressible flow are readily usable here, which can be a good starting point if you want a quick try and don't want to read the rest of the document. In each subfolder, the *.jl file is the main script that actually works. Paraview state file(s) *.pvsm may be also helpful in quick visualization, by open Paraview-File-Load State.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nMetaFEM is in a primitive stage and under development. Any input, e.g., questions of usage, bugs, feature requests, or any ideas to make it better, will be very welcomed. Please feel free to open an issue on Github or directly email me at jiaxixie2022@u.northwestern.edu.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Through REPL-Pkg, i.e., Press ] in Julia REPL to enter pkg>, then:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MetaFEM","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or directly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MetaFEM\")","category":"page"}]
}
