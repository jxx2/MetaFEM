<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Thermal conduction in a pikachu · MetaFEM.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="MetaFEM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">MetaFEM.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><a class="tocitem" href="../../../../api/">APIs</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Thermal conduction in a pikachu</a><ul class="internal"><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Physics"><span>Physics</span></a></li><li><a class="tocitem" href="#Assembly"><span>Assembly</span></a></li><li><a class="tocitem" href="#Run-and-Output"><span>Run &amp; Output</span></a></li><li><a class="tocitem" href="#Bare-script"><span>Bare script</span></a></li></ul></li><li><a class="tocitem" href="../../thermal_stripe/thermal_stripe/">Various thermal boundary conditions on a 2D stripe</a></li><li><a class="tocitem" href="../../cantilever/cantilever/">Linear elastic cantilever bending</a></li><li><a class="tocitem" href="../../stress_concentration/stress_concentration/">Stress concentration of a hole</a></li><li><a class="tocitem" href="../../cylinderflow/cylinderflow/">Incompressible flow pass a cylinder</a></li><li><a class="tocitem" href="../../lid_driven_cavity/lid_driven_cavity/">Lid-driven cavity</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Thermal conduction in a pikachu</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Thermal conduction in a pikachu</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jxx2/MetaFEM.jl/blob/master/docs/src/examples/src/pikachu/pikachu.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Thermal-conduction-in-a-pikachu"><a class="docs-heading-anchor" href="#Thermal-conduction-in-a-pikachu">Thermal conduction in a pikachu</a><a id="Thermal-conduction-in-a-pikachu-1"></a><a class="docs-heading-anchor-permalink" href="#Thermal-conduction-in-a-pikachu" title="Permalink"></a></h1><p><img src="../pika1.png" alt="pika1"/></p><p>Let&#39;s begin with simulating the temperature distribution on a pikachu. Among all the examples, this example contains the most detailed discussion. The source with data/visualization can also be found <a href="https://github.com/jxx2/MetaFEM.jl/tree/main/examples/heat_transfer_solid">here</a>.</p><p>First, we load the package by:</p><pre><code class="language-julia hljs">using MetaFEM</code></pre><p>Then we define a &quot;FEM_Domain&quot; of dimension 3, which will finally turn to one linear system <span>$Kx = d$</span>.</p><pre><code class="language-julia hljs">fem_domain = FEM_Domain(; dim = 3)</code></pre><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>Every FEM simulation needs a mesh. In MetaFEM we need to read mesh as (vert, connections). &quot;vert&quot; is a <span>$dim \times N_n$</span> CuArray of coordinates, where <span>$N_n$</span> is the number of nodes, while &quot;connections&quot; is a <span>$N_v \times N_e$</span> CuArray of sequenced node IDs where <span>$N_v$</span> is the number of nodes in each element and <span>$N_e$</span> is the total element number, very similar to the mesh loading process in other fields, e.g., for plotting. The input mesh is assumed to be at first order, i.e., every node is the end of some edges. Higher order elements will be regenerated inside MetaFEM based on the first order mesh.</p><p>Here we read the mesh from file 3D_COMSOL_Mesh.mphtxt generated by COMSOL, which can be found <a href="https://github.com/jxx2/MetaFEM.jl/tree/main/examples/heat_transfer_solid">here</a> and should be copied to the same folder as your script. The vertices coordinates are divided by 100 here because the source mesh of our pikachu has the length scale in cm. As for the function names, the mesh of the body is named a TotalMesh, in contrast to BoundaryMesh which only contains the boundary nodes/edges/faces</p><pre><code class="language-julia hljs">element_shape = :SIMPLEX
src_fname = joinpath(@__DIR__, &quot;3D_COMSOL_Mesh.mphtxt&quot;)
vert, connections = read_Mesh(src_fname)
ref_mesh = construct_TotalMesh(vert ./ 100, connections)</code></pre><p>Now we add a &quot;workpiece&quot;, an object which will be assigned physics later, to our FEM_Domain, which returns wp_ID (the workpiece ID) for later reference by simply &quot;fem_domain.workpieces[wp_ID]&quot;. Multiple workpieces in the same domain will be solved in coupling as a monolithic linear system <span>$Kx = d$</span>.</p><pre><code class="language-julia hljs">wp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)</code></pre><p>We also need to define boundary. We call &quot;get_BoundaryMesh&quot; to return all the IDs for the boundary faces (segments in 2D domain). We assign all of them as one boundary, assuming our pikachu is under convection in homogeneous air.</p><pre><code class="language-julia hljs">fIDs = get_BoundaryMesh(ref_mesh)
flux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)</code></pre><h2 id="Physics"><a class="docs-heading-anchor" href="#Physics">Physics</a><a id="Physics-1"></a><a class="docs-heading-anchor-permalink" href="#Physics" title="Permalink"></a></h2><p>Then we are going to define physics, the most joyful part of the code. On the one hand, the mathematical formulation for the heat conduction in the pikachu <span>$\Omega$</span> with convection on <span>$\partial\Omega$</span> is:</p><p class="math-container">\[\text{variable}\quad T,\qquad\text{parameters}\quad C,k,h,T_{env},s\]</p><p class="math-container">\[-k(T_{,i},T_{,i})+(T,s)=0,\qquad in\quad\Omega\]</p><p class="math-container">\[h(T,T_{env}-T)=0,\qquad on\quad\partial\Omega\]</p><p>where <span>$T$</span> is the body temperature, <span>$C$</span> is the volumetric heat capacity, <span>$k$</span> is the thermal conductivity, <span>$h$</span> is the convective coefficient, <span>$T_{env}$</span> is the environment (air) temperature, <span>$s$</span> is the heat source.</p><p>On the other hand, the code is:</p><pre><code class="language-julia hljs">C = 1.
k = 0.6
h = 25.
Tₑₙᵥ = 273.15 + 20

@External_Sym (s, CONTROLPOINT_VAR)
@Def begin
    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)
    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)
end
assign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)
assign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)</code></pre><p>Fairly self-illustrative, isn&#39;t it? Remarks:</p><ul><li>C, k, h, <span>$T_{env}$</span> are just Julia native variables, i.e., floating-point numbers (with SI base units);</li><li>s is an external variable, which means they will not be differentiated and allocated in the final linear system <span>$Kx=d$</span>, but they will have a number per workpiece controlpoint (alias for the FEM mesh vertex, in contrast to the first order mesh nodes we used to describe the geometry).</li><li>Only the variables which are actually in use (in a weak-form assigned to a workpiece) will be allocated. Also, we did not define T because MetaFEM has default variable declaration of the <a href="https://github.com/jxx2/MetaFEM.jl/blob/main/src/symbolics/01_Types.jl">following code</a>:</li></ul><pre><code class="language-julia hljs">@External_Sym (x, CONTROLPOINT_VAR) (y, CONTROLPOINT_VAR) (z, CONTROLPOINT_VAR) (t, GLOBAL_VAR) (dt, GLOBAL_VAR)
@External_Sym (F, INTEGRATION_POINT_VAR) (f, INTEGRATION_POINT_VAR) (n, INTEGRATION_POINT_VAR) δ
@Sym u p T</code></pre><ul><li>By @Def, the expressions are parsed. The basic unit for FEM weak-form is a bilinear form, denoted by the function &quot;Bilinear&quot;. The symbols or numbers in curly bracket define the subscripts. The semicolon &quot;;&quot; in code is the comma &quot;,&quot; in math separating the component index and the derivatives while the comma &quot;,&quot; in code is just a separator betweewn symbols. The symbol &quot;t&quot; is reserved only for the derivative index to denote the time derivative. Note, a Julia variable like k is evaluated and fixed in @Def parsing, so if we want a changeable k, we should use:</li></ul><pre><code class="language-julia hljs">@External_Sym (k, GLOBAL_VAR)</code></pre><ul><li>The system understands free/dumb indices so the script should look just like something one may write on the blackboard in a mechanics class.</li><li>We do not have fixed high-level concepts like &quot;Dirichlet/Neumann/Robin/... boundary&quot;, everything is just a weak-form, capable of full customization;</li><li>&quot;assign_WorkPiece_WeakForm&quot; assigns heat_dissipation to the wp_ID workpiece of the domain fem_domain and &quot;assign_Boundary_WeakForm&quot; assigns conv_boundary to the flux_bg_ID boundary of the the wp_ID workpiece of the domain fem_domain.</li></ul><h2 id="Assembly"><a class="docs-heading-anchor" href="#Assembly">Assembly</a><a id="Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly" title="Permalink"></a></h2><p>After defining physics, we need to collect, classify and number all the variables each workpiece. Although there is a shorter version:</p><pre><code class="language-julia hljs">initialize_LocalAssembly(fem_domain::FEM_Domain; explicit_max_sd_order::Integer) = initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order)</code></pre><p>we still prefer to the following way which defines explicitly the maximum spatial differential order per workpiece, i.e., weak-form spatial derivatives order higher than &quot;explicit_max_sd_order&quot; will not be stored to save memory. Memory usage for interpolation points ~ <span>$(order + 1)^{dim}$</span>, e.g., 2-order to 1-order in 3D has a 27 to 8 memory usage difference.</p><pre><code class="language-julia hljs">initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)</code></pre><p>Then we regenerate our mesh to second order serendipity elements with fifth Gaussian quadrature. Note, &quot;mesh_Classical&quot; needs to know variables so it must be after &quot;initialize_LocalAssembly&quot;.</p><pre><code class="language-julia hljs">mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)</code></pre><p>Also we need to generate the simulation codes, where &quot;domain_ID&quot; is just used to generated function symbol.</p><pre><code class="language-julia hljs">compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)</code></pre><h2 id="Run-and-Output"><a class="docs-heading-anchor" href="#Run-and-Output">Run &amp; Output</a><a id="Run-and-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Run-and-Output" title="Permalink"></a></h2><p>Now we are ready for simulation! First update geometry information such as the Jacobians/interpolation values/... by:</p><pre><code class="language-julia hljs">for wp in fem_domain.workpieces
    update_Mesh(fem_domain.dim, wp, wp.element_space)
end</code></pre><p>Then we allocate the <span>$K, x \text{ and } d$</span>:</p><pre><code class="language-julia hljs">assemble_Global_Variables(fem_domain = fem_domain)</code></pre><p>We also need to choose a linear solver. For a small-sized problem, CPU solver, defined <a href="https://github.com/jxx2/MetaFEM.jl/blob/main/src/solver/linear_solver/01_Direct_Solver.jl">here</a> using LinearAlgebra.lu, is actually faster, although the data will still be passed to GPU anyway.</p><pre><code class="language-julia hljs">fem_domain.linear_solver = solver_LU_CPU
fem_domain.globalfield.converge_tol = 1e-5</code></pre><p>Assign initial values and external variables:</p><pre><code class="language-julia hljs">cpts = fem_domain.workpieces[1].mesh.controlpoints
cp_IDs = findall(cpts.is_occupied)
cpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn&#39;t need initial values, but just for completeness. The default initial values are zeros.
cpts.s[cp_IDs] .= 1600.</code></pre><p>Solve <span>$K(\Delta x) = d$</span> and do <span>$x$</span> += <span>$\Delta x$</span>:</p><pre><code class="language-julia hljs">update_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)</code></pre><p>Pull global x to local variables. (Pushing local to global is included in &quot;update_OneStep&quot;):</p><pre><code class="language-julia hljs">dessemble_X(fem_domain.workpieces, fem_domain.globalfield)</code></pre><p>Save to vtk, note, scale is only for length:</p><pre><code class="language-julia hljs">write_VTK(joinpath(@__DIR__, &quot;3D_MetaFEM_Result.vtk&quot;), fem_domain.workpieces[1]; scale = 100)</code></pre><p><img src="../pika2.png" alt="pika2"/></p><h2 id="Bare-script"><a class="docs-heading-anchor" href="#Bare-script">Bare script</a><a id="Bare-script-1"></a><a class="docs-heading-anchor-permalink" href="#Bare-script" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MetaFEM

fem_domain = FEM_Domain(; dim = 3)

element_shape = :SIMPLEX
src_fname = joinpath(@__DIR__, &quot;3D_COMSOL_Mesh.mphtxt&quot;)
vert, connections = read_Mesh(src_fname)
ref_mesh = construct_TotalMesh(vert ./ 100, connections)

wp_ID = add_WorkPiece(ref_mesh; fem_domain = fem_domain)

fIDs = get_BoundaryMesh(ref_mesh)
flux_bg_ID = add_Boundary(wp_ID, fIDs; fem_domain = fem_domain)

C = 1.
k = 0.6
h = 25.
Tₑₙᵥ = 273.15 + 20

@External_Sym (s, CONTROLPOINT_VAR)
@Def begin
    heat_dissipation = - k * Bilinear(T{;i}, T{;i}) + Bilinear(T, s)
    conv_boundary = h * Bilinear(T, Tₑₙᵥ - T)
end
assign_WorkPiece_WeakForm(wp_ID, heat_dissipation; fem_domain = fem_domain)
assign_Boundary_WeakForm(wp_ID, flux_bg_ID, conv_boundary; fem_domain = fem_domain)

initialize_LocalAssembly(fem_domain.dim, fem_domain.workpieces; explicit_max_sd_order = 1)

mesh_Classical([wp_ID]; shape = element_shape, itp_type = :Serendipity, itp_order = 2, itg_order = 5, fem_domain = fem_domain)

compile_Updater_GPU(domain_ID = 1, fem_domain = fem_domain)

for wp in fem_domain.workpieces
    update_Mesh(fem_domain.dim, wp, wp.element_space)
end

assemble_Global_Variables(fem_domain = fem_domain)

fem_domain.linear_solver = solver_LU_CPU
fem_domain.globalfield.converge_tol = 1e-5

cpts = fem_domain.workpieces[1].mesh.controlpoints
cp_IDs = findall(cpts.is_occupied)
cpts.T[cp_IDs] .= Tₑₙᵥ # Static problem doesn&#39;t need initial values, but just for completeness. The default initial values are zeros.
cpts.s[cp_IDs] .= 1600.

update_OneStep(fem_domain.time_discretization; fem_domain = fem_domain)

dessemble_X(fem_domain.workpieces, fem_domain.globalfield)

write_VTK(joinpath(@__DIR__, &quot;3D_MetaFEM_Result.vtk&quot;), fem_domain.workpieces[1]; scale = 100)

# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../../api/">« APIs</a><a class="docs-footer-nextpage" href="../../thermal_stripe/thermal_stripe/">Various thermal boundary conditions on a 2D stripe »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 16 November 2021 20:03">Tuesday 16 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
